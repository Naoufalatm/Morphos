# Elixir-To-C Transpiler

## Comprehensive Overview

### 1. Introduction

* Brief Overview

* Prior Knowledge

* Project RoadMap

* Project Motivation

* Project Description

  * subset of ELIXIR
  * Target Features

* Architecture overview

  * High-level Architecture (Elixir Language)
  * Low-level Architecture (C language)

* Key design goals

### 2. Transpilation Process

* Parsing Elixir source code
  * Elixir AST
  * Parsing
* Translation strategy
  * Figure : Transpiled Types Elixir->C
  * Mapping Elixir constructs to C
* Code generation techniques
  * Linking with Staticaly Compiled C Runtime

### 3. Runtime

* Runtime architecture
  * Figure : Runtime Components
    * Scheduler
    * Greenthread
    * Threads_array
* Concurrency model
  * Concurrency Paradigm
  * Implementation
  * Benifits & Limitations
* Fault Tolerance
  * Let it crush philosophy
  * Implementation
  * Limitation & Future works
* Performance considerations
  * Overheads
    * Number of Threads
    * TIME_SLICE Switching Interval
  * Scheduling Policy (round_robin)

### 4. Code Walkthrough

* Key transpiler components
  * Figure : Modules Interactions
  * Transpiler Module
  * Transpiler.Parser
  * Transpiler.Tree.Expression
  * Transpiler.Tree.MainBlock
  * Transpiler.CodeGenerator
* Runtime implementation 
  * Figure :
  * Headers:
    * anonymous.h
    * obz_scheduler.h
    * scheduler.h
    * thread.h
  * Source Code
    * fallback.c
    * fault_tolerance.c
    * scheduler.c
    * thread.c
* Code snippets with explanations

### 5. Live Demonstration

#### 5.1 Examples

* Basic Literals translation
  * Example Blocks x3
* Proof Of Concept

#### 5.2 Comparison

* Fault Tolerance
* Concurrenct
  * Pthreads vs Obz_Runtime

### 6. Limitations and Future Work

* Current constraints
* Potential improvements

### 7. Conclusion

* Project summary
* Key learnings
* Potential use cases

### 8. References

## 1- Introduction

### Brief Overview

#### **Objective:**

Our primary objective is to develop a transpiler that converts Elixir code into high-performance C code. By doing so, we aim to preserve Elixir's robust functional programming paradigms while maintaining its powerful concurrency capabilities through the use of green threads.

##### **Key Features:**

* **Preservation of Functional Paradigms:** Ensuring that the functional aspects of Elixir, such as immutable data structures and first-class functions, are accurately represented in the generated C code.
* **Concurrency with Green Threads:** Implementing green threads in C to maintain Elixir's ability to handle concurrent operations efficiently.
* **Significance:**
  * **Bridging High-Level and Low-Level:** This project serves as a bridge between the expressive, high-level nature of Elixir and the performance-centric environment of C. It allows developers to leverage the strengths of both languages.
  * **Beyond BEAM VM:** By enabling Elixir-like abstractions in C, we open up possibilities for deploying Elixir code in environments where the BEAM VM is not suitable or available.
* **Expected Outcome:**
  * **Efficient C Code:** The transpiler will produce C code that not only mirrors the functionality of the original Elixir code but also leverages its concurrency and functional features for scalable and high-performance applications.

### Prior Knowledge

Understanding the foundational concepts of **green threads**, their comparison with **POSIX processes/threads**, and the **round-robin scheduling** algorithm is essential for comprehending the design and implementation of the transpiler and runtime architecture in this project.

---

#### **1. Green Threads Concept**

**Green threads** are a user-level threading mechanism that facilitates concurrent execution within a single operating system (OS) thread. Unlike traditional threads managed by the OS, green threads are managed entirely in user space by a runtime library or virtual machine.

**Key Characteristics:**

* **User-Level Management:**

  * Green threads are scheduled and managed by the application or a runtime library rather than the OS kernel. This allows for greater control over thread scheduling and management.

* **Lightweight:**

  * Creating and switching between green threads typically incurs less overhead compared to OS-level threads. This makes green threads suitable for applications requiring a large number of concurrent tasks.

* **Portability:**

  * Since green threads are implemented in user space, they can offer consistent behavior across different operating systems without relying on OS-specific threading implementations.

* **Cooperative Scheduling:**

  * Often, green threads use cooperative multitasking, where threads yield control explicitly, allowing other threads to execute. However, in this project, a preemptive round-robin scheduler is implemented to manage thread execution automatically.

**Relevance to the Project:**

* **Concurrency Implementation:**

  * Green threads form the backbone of the runtime's concurrency model, enabling the execution of multiple anonymous functions concurrently within the generated C code.

* **Resource Efficiency:**

  * By utilizing green threads, the runtime can handle thousands of concurrent tasks with minimal memory and CPU overhead, aligning with the project's goal of high scalability.

* **Custom Scheduling:**

  * Implementing green threads allows the project to design and integrate a custom scheduler (round-robin) tailored to its specific concurrency and performance requirements.

---

#### **2. Green Threads vs. POSIX Processes/Threads in C**

When implementing concurrency in C, developers have the option to use **POSIX processes** or **POSIX threads (pthreads)**, which are managed by the OS. Understanding the differences between these and green threads is crucial for making informed design decisions.

**a. POSIX Processes:**

* **Definition:**

  * Independent execution units with their own memory space, created using system calls like `fork()`.

* **Characteristics:**

  * **Isolation:** Each process has a separate memory space, enhancing fault tolerance as one process crashing does not affect others.
  * **High Overhead:** Creating and managing processes is resource-intensive due to the need for duplicating memory and resources.
  * **Inter-Process Communication (IPC):** Communication between processes requires explicit mechanisms like pipes, sockets, or shared memory, which can be complex and slow.

* **Use Cases:**

  * Suitable for applications requiring strong isolation and security between execution units, such as server applications handling multiple clients.

**b. POSIX Threads (pthreads):**

* **Definition:**

  * Lightweight execution units within a single process, sharing the same memory space, created using the pthread library.

* **Characteristics:**

  * **Shared Memory:** Threads within the same process can easily share data, facilitating efficient communication and data sharing.
  * **Lower Overhead than Processes:** Creating and managing threads is less resource-intensive compared to processes, allowing for higher concurrency.
  * **Synchronization Requirements:** Shared memory necessitates synchronization mechanisms like mutexes and semaphores to prevent race conditions, which can introduce complexity and potential performance bottlenecks.

* **Use Cases:**

  * Ideal for applications requiring fine-grained parallelism and efficient data sharing, such as computational tasks and real-time data processing.

**c. Green Threads:**

* **Definition:**

  * User-level threads managed entirely in user space by a runtime library or virtual machine, not relying on OS-level thread management.

* **Characteristics:**

  * **Custom Scheduling:** Allows for tailored scheduling algorithms, such as the preemptive round-robin scheduler implemented in this project.
  * **Lightweight:** Minimal overhead in thread creation and context switching, enabling the management of a large number of concurrent threads.
  * **Isolation:** Similar to POSIX processes, green threads can maintain isolated execution contexts (e.g., isolated heaps) to enhance fault tolerance.
  * **Flexibility:** Can implement advanced concurrency models and fault tolerance mechanisms not readily achievable with POSIX threads.

**Comparison Summary:**

| Feature                | POSIX Processes           | POSIX Threads (pthreads)          | Green Threads                        |
| ---------------------- | ------------------------- | --------------------------------- | ------------------------------------ |
| **Management**         | OS-level                  | OS-level                          | User-level (runtime library)         |
| **Memory Space**       | Separate                  | Shared within process             | Can be isolated (customizable)       |
| **Overhead**           | High (resource-intensive) | Moderate (lighter than processes) | Low (very lightweight)               |
| **Communication**      | IPC mechanisms required   | Direct shared memory              | Direct or through runtime mechanisms |
| **Scheduling Control** | OS-managed                | OS-managed                        | Customizable (e.g., round-robin)     |
| **Scalability**        | Limited by high overhead  | Moderate scalability              | High scalability                     |
| **Fault Isolation**    | Strong isolation          | Weak isolation (shared memory)    | Configurable isolation               |

**Relevance to the Project:**

* **Choice of Green Threads:**

  * Opting for green threads over POSIX processes or threads aligns with the project's requirements for high concurrency and low overhead. Green threads offer the flexibility to implement custom scheduling and fault tolerance mechanisms tailored to the project's specific needs.

* **Enhanced Control:**

  * By managing threads in user space, the project gains complete control over thread behavior, scheduling policies, and fault handling strategies, which is essential for implementing advanced features like the "Let it Crash" philosophy and supervisor trees.

* **Resource Efficiency:**

  * Green threads enable the runtime to handle a large number of concurrent tasks without the significant memory and CPU overhead associated with POSIX processes or even pthreads, ensuring optimal performance and scalability.

---

#### **3. Round Robin in Scheduling**

**Round Robin (RR)** is a widely used scheduling algorithm in operating systems and concurrent runtime environments. It is known for its simplicity and fairness in allocating CPU time among multiple execution units, such as processes or threads.

**Key Characteristics:**

* **Time Slices (Quanta):**

  * Each thread is assigned a fixed time slice or quantum during which it can execute. If the thread does not complete its task within this time, it is preempted, and the next thread in the queue is scheduled.

* **Cyclic Order:**

  * Threads are arranged in a circular queue. After a thread's time slice expires, it is moved to the end of the queue, and the scheduler picks the next thread at the front.

* **Fairness:**

  * Ensures that all threads receive an equal opportunity to execute, preventing any single thread from monopolizing the CPU.

* **Predictable Performance:**

  * The fixed time slices provide predictable response times, making RR suitable for real-time and time-sensitive applications.

**Advantages:**

* **Simplicity:**

  * Easy to implement and understand, with straightforward logic for managing thread queues and time slices.

* **Fairness:**

  * Guarantees that each thread gets a fair share of CPU time, which is essential for maintaining balanced performance across concurrent tasks.

* **Responsiveness:**

  * Provides timely execution of threads, ensuring that no thread experiences indefinite delays.

**Disadvantages:**

* **Context Switching Overhead:**

  * Frequent preemption and context switching can introduce significant overhead, especially with a large number of threads or very short time slices.

* **Time Slice Selection:**

  * Choosing an appropriate time slice duration is crucial. Too short can lead to excessive context switching, while too long can cause delays in thread responsiveness.

* **Not Optimal for All Workloads:**

  * May not perform well for threads with varying execution times, as short tasks can be delayed behind long-running threads.

**Relevance to the Project:**

* **Preemptive Multitasking:**

  * Implementing a preemptive round-robin scheduler allows the runtime to manage green threads efficiently, ensuring that all concurrent tasks receive adequate CPU time without manual intervention.

* **Fair CPU Time Distribution:**

  * Aligns with the project's goal of high scalability and balanced concurrency by preventing any single green thread from monopolizing system resources.

* **Performance Optimization:**

  * By carefully selecting the time slice duration and optimizing context switching mechanisms, the round-robin scheduler can minimize overheads and maintain high system responsiveness.

* **Scalability:**

  * The simplicity and fairness of the round-robin algorithm make it suitable for managing a large number of green threads, supporting the project's requirement for handling extensive parallelism.

**Implementation in the Project:**

* **Scheduler Module:**

  * The **Scheduler** node in the runtime architecture implements the round-robin scheduling policy, cycling through the **Global Threads Array** and allocating time slices to each green thread.

* **Context Switching:**

  * Efficient context switching mechanisms are employed to reduce overhead, ensuring that the scheduler can manage numerous green threads without significant performance penalties.

* **Adaptability:**

  * While the current implementation uses a pure round-robin approach, the scheduler's design allows for future enhancements, such as dynamic time slices or priority-based adjustments, to optimize performance based on runtime conditions.

---

<!-- livebook:{"break_markdown":true} -->

### Project ROADMAP

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
graph LR
    Input[/Elixir/]:::input --> Transpiler[Transpiler Phase]:::transpiler
    Transpiler --> Runtime[Runtime]:::runtime
    Runtime --> Output[\Executable\]:::output

    classDef input fill:#E6E6FA,stroke:#E6E6FA,stroke-width:2px,color:#000;
    classDef transpiler fill:#FFD580,stroke:#FFA500,stroke-width:2px,color:#000;
    classDef runtime fill:#87CEEB,stroke:#00008B,stroke-width:2px,color:#000;
    classDef output fill:#90EE90,stroke:#90EE90,stroke-width:2px,color:#000;
```

<!-- livebook:{"break_markdown":true} -->

### Project Roadmap Overview

* **Input: Elixir**

  * **Description:**
    * The project begins with the user providing raw Elixir source code.
    * Elixir's high-level syntax and concurrency features serve as the foundation for the transpilation process.
  * **Key Activities:**
    * Collection of Elixir modules, functions, and anonymous functions.
    * Ensuring the Elixir code adheres to the expected syntax and semantics for accurate transpilation.

* **Transpiler Phase**

  * **Description:**
    * This phase involves converting the input Elixir code into equivalent C code through a systematic transpilation process.
    * The transpiler ensures that core Elixir semantics are retained in the generated C code.
  * **Key Activities:**
    * **Parsing:** Analyzing the Elixir code to generate an Abstract Syntax Tree (AST), capturing the structural and syntactic elements.
    * **Type Mapping:** Translating Elixir data types and constructs into corresponding C types, maintaining type safety and functional integrity.
    * **Handling Anonymous Functions:** Utilizing C macros and GCC statement blocks to emulate Elixir's anonymous functions within the C environment.
    * **Code Generation:** Producing well-structured and optimized C code that mirrors the behavior of the original Elixir code.
    * **Modularity:** Organizing the transpiler into specialized modules (`Transpiler.Tree.Expression`, `Transpiler.Tree.Mainblock`, `Transpiler.CodeGenerator`) to enhance maintainability and scalability.

* **Runtime**

  * **Description:**
    * The runtime environment executes the transpiled C code, implementing concurrency and fault tolerance through green threads.
    * It ensures efficient execution, scalability, and robustness of the generated executable.
  * **Key Activities:**
    * **Green Thread Management:** Creating and managing lightweight green threads to handle concurrent execution of tasks.
    * **Scheduler Implementation:** Utilizing a preemptive round-robin scheduling algorithm to allocate CPU time slices fairly among green threads.
    * **Fault Tolerance Mechanisms:** Incorporating the "Let it Crash" philosophy to isolate faults and maintain system stability even when individual threads fail.
    * **Resource Management:** Efficiently handling memory allocation through isolated heaps and minimizing overheads associated with thread management.
    * **Integration with Transpiler:** Ensuring seamless interaction between the generated C code and the runtime's concurrency and fault tolerance systems.

* **Output: Executable**

  * **Description:**
    * The final phase produces a compiled executable binary from the transpiled C code.
    * This executable embodies the functionality and concurrency model of the original Elixir code, optimized for performance and reliability.
  * **Key Activities:**
    * **Compilation:** Using a C compiler to compile the generated C code into an executable binary.
    * **Linking:** Resolving dependencies and linking the executable with necessary libraries, including the custom green thread library.
    * **Deployment:** Preparing the executable for deployment, ensuring it runs efficiently on the target environment.
    * **Testing and Validation:** Conducting thorough testing to verify that the executable behaves as expected, maintaining the semantics of the original Elixir code.

<!-- livebook:{"break_markdown":true} -->

### Project Motivation

* Exploration of Transpiling Elixir’s Functional and Concurrent Features into C: We aim to thoroughly explore the potential of converting Elixir's functional and concurrent paradigms into C, ensuring that the core functionalities are retained and optimized for performance.

* Enabling Elixir’s Abstractions in Non-BEAM Environments: Another key goal is to make Elixir's abstractions usable in environments where the BEAM VM is not feasible. This expands the applicability of Elixir's features to a broader range of systems and use cases.

<!-- livebook:{"break_markdown":true} -->

### Project Description :

#### Subset of Elixir :

| Name                   | Elixir Subset   | C lang counterpart                                                |
| ---------------------- | --------------- | ----------------------------------------------------------------- |
| variable binding       | x = 10          | int x = 10 ;                                                      |
| -                      | y = "hamid "    | char* y = "hamid"                                                 |
| anonymous function     | fn _ -> :ok end | lambda(void, (void* arg), { ret :ok ;})                           |
| spawning processes     | &spawn/1        | green_thread_creat(lambda(void, (void* arg), { ret :ok ;}), NULL) |
| printing to the stdout | &IO.inspect/1   | printf("%s /n")                                                   |

##### Target Features:

**While our current transpiler handles a foundational subset of Elixir, our vision encompasses more advanced features to fully leverage Elixir's strengths in the C environment.**

---

#### **a. Fault Tolerance**

**Objective:**

* *Implement mechanisms to handle runtime errors gracefully.*
* *Isolate faults to prevent system-wide crashes.*

**Key Activities:**

1. **Error Handling Mechanisms:**

   * *Develop robust error detection and handling protocols within the runtime to manage unexpected situations without terminating the entire system.*

2. **Isolation of Faults:**

   * *Ensure that failures in individual greenthreads do not propagate, maintaining the stability and reliability of the overall system.*

3. **Recovery Strategies:**

   * *Implement strategies such as thread restarts or supervisor trees to recover from faults, aligning with Elixir's "Let it Crash" philosophy.*

**Benefits:**

* *Enhances system robustness by preventing single points of failure.*
* *Maintains continuous operation even in the face of individual thread failures.*
* *Aligns with Elixir's approach to building resilient and fault-tolerant applications.*

---

#### **b. Out of The Box Concurrency**

**Objective:**

* *Enable seamless concurrent execution without additional setup.*
* *Provide a pre-configured green thread scheduler for efficient task management.*

**Key Activities:**

1. **Seamless Concurrent Execution:**

   * *Design the runtime to automatically handle concurrent tasks, requiring no manual intervention from the user.*

2. **Pre-configured Scheduler:**

   * *Integrate a preemptive round-robin scheduler within the runtime to manage green threads efficiently from the outset.*

3. **Efficient Task Management:**

   * *Optimize the runtime to handle multiple concurrent tasks with high scalability and resource efficiency, ensuring that the system remains performant under heavy loads.*

**Benefits:**

* *Reduces the complexity for users by providing built-in concurrency management.*
* *Ensures high scalability, allowing the system to handle numerous concurrent tasks effortlessly.*
* *Maximizes resource efficiency, making the runtime suitable for performance-critical applications.*

---

<!-- livebook:{"break_markdown":true} -->

### Architecture Overview

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
graph TD
    subgraph User Input
        A[Elixir Code]
    end

    subgraph AST Generation
        B[AST Generator]
    end

    subgraph Code Management
        C[Code Parser and Expression Generator]
        D[Code Generator]
    end

    subgraph Output
        E[Target Language C Code]
    end

    A -->|Generates AST| B
    B -->|AST Node 1| C
    B -->|AST Node 2| C
    B -->|AST Node 3| C
    B -->|...| C
    C -->|Parsed Code| D
    D -->|Generates| E

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
    style C fill:#bef,stroke:#333,stroke-width:2px
    style D fill:#fbb,stroke:#333,stroke-width:2px
    style E fill:#ffb,stroke:#333,stroke-width:2px

```

##### Description

* **User Input**

  * **Elixir Code**: The process begins with the user providing Elixir source code that needs to be translated into C.

* **AST Generation**

  * **AST Generator**: The Elixir code is parsed to create an Abstract Syntax Tree (AST), representing the structural syntax of the code.

* **Code Management**

  * **Code Parser**: Individual AST nodes are parsed to understand their specific constructs and semantics.
  * **Expression Generator**: Generates expressions based on the parsed AST nodes to facilitate code translation.

* **Code Generation**

  * **Code Generator**: Combines parsed code and generated expressions to construct the corresponding C code.

* **Output**

  * **Target C Code**: The final output is the generated C code that mirrors the functionality of the original Elixir code.

###### Workflow Overview

* **Elixir Code Input**: Users provide Elixir code as the starting point.
* **AST Creation**: The AST Generator converts the Elixir code into an Abstract Syntax Tree.
* **Parsing and Expression Generation**: Each node of the AST is parsed, and corresponding expressions are generated.
* **C Code Generation**: The Code Generator uses the parsed information to produce equivalent C code.
* **Final Output**: The translated C code is delivered as the final output.

<!-- livebook:{"break_markdown":true} -->

### Key Design Goals

* **Flexible Anonymous Functions in C**

  * **Objective**: Overcome C's strict typing limitations to implement versatile anonymous functions.
  * **Approach**: Leverage C's powerful macro system, including GCC statement blocks, to create flexible and reusable anonymous function constructs.

* **Simple Green Thread Library**

  * **Objective**: Facilitate concurrent programming in C with minimal overhead.
  * **Approach**: Develop a lightweight green thread library that enables efficient multitasking within C applications, providing an easy-to-use interface for managing threads without relying on operating system-level threading.

## 2- Transpilation Process

#### 2.1- Parsing Elixir source code

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
graph 
    subgraph Type Mappings
        A1[x = 0 #40;int#41;] --> B1[int x = 0;]
        A2[y = 1.2 #40;float#41;] --> B2[float y = 1.2;]
        A3[z = &quot;this is a string&quot; #40;string#41;] --> B3[char* z = &quot;this is a string&quot;;]
        A4[fn = fn -&gt; :ok end #40;Anonymous function #40;void#41; -&gt; #40;:ok#41;#41;] --> B4[lambda#40;#40;void#41;, #40;void *arg#41;,  ret :ok  #41;;]
    end

    style A1 fill:#f9f,stroke:#333,stroke-width:2px
    style B1 fill:#bbf,stroke:#333,stroke-width:2px
    style A2 fill:#f9f,stroke:#333,stroke-width:2px
    style B2 fill:#bbf,stroke:#333,stroke-width:2px
    style A3 fill:#f9f,stroke:#333,stroke-width:2px
    style B3 fill:#bbf,stroke:#333,stroke-width:2px
    style A4 fill:#f9f,stroke:#333,stroke-width:2px
    style B4 fill:#bbf,stroke:#333,stroke-width:2px

```

##### Integer Assignment

* Elixir Representation: x = 0 (int)
* C Translation: int x = 0;
* Description:
  * Elixir Side: An integer variable x is assigned the value 0.
  * C Side: The equivalent C code declares an integer x and initializes it with 0.
* Purpose: Ensures that integer assignments in Elixir are accurately translated to C's strict typing system.

##### Float Assignment

* Elixir Representation: y = 1.2 (float)
* C Translation: float y = 1.2;
* Description:
  * Elixir Side: A floating-point variable y is assigned the value 1.2.
  * C Side: The C code declares a float variable y and initializes it with 1.2.
* Purpose: Maintains the precision of floating-point numbers when converting from Elixir to C.

##### String Assignment

* Elixir Representation: z = "this is a string" (string)
* C Translation: char* z = "this is a string";
* Description:
  * Elixir Side: A string variable z is assigned the value "this is a string".
  * C Side: The C code declares a character pointer z and initializes it with the string literal.
* Purpose: Properly handles string data types, translating Elixir's high-level string constructs to C's character arrays.

##### Anonymous Function Assignment

* Elixir Representation: fn = fn -> :ok end (Anonymous function (void) -> (:ok))
* C Translation: lambda((void), (void *arg), ret :ok );
* Description:
  * Elixir Side: An anonymous function fn is defined, which takes no arguments and returns :ok.
  * C Side: The C code uses a lambda function signature that takes a void argument and returns :ok.
* Purpose: Implements Elixir's anonymous functions in C by leveraging C's lambda capabilities, allowing for functional programming paradigms within the C environment.

##### Overall Role in the Project

* **Seamless Type Translation:** The Type Mappings component ensures that variables and functions defined in Elixir are accurately and efficiently translated into their C counterparts, respecting C’s strict typing rules.

* **Macro Utilization:** By leveraging C's powerful macro system, the project can handle complex type translations and function mappings, such as anonymous functions, which are not natively supported in C.

* **Foundation for Code Generation:** These mappings serve as the foundational layer for the Code Generator module, enabling the generation of syntactically correct and semantically equivalent C code from the parsed Elixir AST.

* **Enhancing Flexibility and Concurrency:** Coupled with your design goals, accurate type mappings facilitate the implementation of flexible anonymous functions and the development of a simple green thread library, thereby enhancing C’s capabilities in handling modern programming constructs and concurrent execution.

<!-- livebook:{"break_markdown":true} -->

#### Parsing

##### Parsing in Elixir

Parsing is the foundational step in the transpilation process, where Elixir code is analyzed and transformed into a structured representation that can be manipulated programmatically. Elixir leverages its powerful metaprogramming capabilities to parse code into an Abstract Syntax Tree (AST), which serves as an intermediate representation for subsequent translation phases.

---

##### 1. How Parsing in Elixir Works

##### **Code Parsing**

Elixir utilizes the `Code` module to parse source code into its AST. The primary function responsible for this is `Code.string_to_quoted/1`, which takes a string of Elixir code and converts it into a nested tuple structure representing the syntactic elements of the code.

##### **Parsing Steps**

1. **Lexical Analysis**

   * Elixir's parser performs lexical analysis to break down the raw code into tokens, such as:  
     * **Identifiers** (e.g., variable names).
     * **Operators** (e.g., `+`, `=`).
     * **Literals** (e.g., numbers, strings).
     * **Delimiters** (e.g., `(`, `)`, `,`).

2. **Syntactic Analysis**

   * Organizes tokens into a hierarchical structure based on Elixir's grammar rules.
   * Forms the AST, a tree-like structure capturing relationships and nesting of code constructs such as:
     * Function calls.
     * Variable assignments.
     * Control flow statements.

3. **Macro Expansion**

   * During parsing, Elixir may expand macros (dynamic metaprogramming constructs).
   * Macro expansion results in a detailed AST that incorporates the expanded code.

---

##### 2. AST Parser

### **What is an AST?**

The Abstract Syntax Tree (AST) provides a structured and navigable representation of the source code. It is composed of nested tuples and lists that encapsulate the syntactic structure of the code.

##### **Example AST Structure**

##### **Elixir Code Example**

<!-- livebook:{"force_markdown":true} -->

```elixir
x = 5 + 3
```

##### **Generated AST**

<!-- livebook:{"force_markdown":true} -->

```elixir
{:assign, [context: Elixir, import: Kernel],
 [
   {:x, [context: Elixir], nil},
   {:+, [context: Elixir], [5, 3]}
 ]}
```

##### **Explanation**

* The outer tuple `{:assign, ...}` represents an assignment operation (`=`).
* The first element `{:x, ...}` denotes the variable `x`.
* The second element `{:+, ...}` represents the binary operation `5 + 3`.

---

##### 3. AST Elixir Example and Code Explanation

##### **Complex Example**

##### **Elixir Code**

<!-- livebook:{"force_markdown":true} -->

```elixir
spawn(fn -> IO.inspect("Hello, World!") end)
```

#### **Generated AST**

<!-- livebook:{"force_markdown":true} -->

```elixir
{:spawn, [context: Elixir, import: Kernel],
 [
   {:fn, [context: Elixir],
    [
      {:->, [context: Elixir],
       [
         [],
         {{:., [context: Elixir], [{:__aliases__, [alias: false], [:IO]}, :inspect]},
          [context: Elixir], ["Hello, World!"]}
       ]}
    ]}
 ]}
```

##### **Explanation**

1. **Outer Tuple**

   * Represents the `spawn` function call.

2. **Anonymous Function (`fn -> ... end`)**

   * Represented by the `{:fn, ...}` tuple.
   * Contains a single clause (`{:->, ...}`) which defines:
     * The argument list (`[]`, empty in this case).
     * The body of the function (`IO.inspect("Hello, World!")`).

3. **Function Call (`IO.inspect`)**

   * Represented by `{:., ...}` indicating a dot operator call.
   * The target module (`IO`) is specified using `{:__aliases__, ...}`.
   * The function being called is `:inspect`, with the argument `"Hello, World!"`.

---

<!-- livebook:{"break_markdown":true} -->

#### 2.2- Translation Strategy:

<!-- livebook:{"break_markdown":true} -->

Translating Elixir constructs to C requires a structured approach to map high-level concurrency and functional programming features to C's procedural and low-level paradigms. This section outlines the translation of Elixir constructs, focusing on the `spawn` function and code generation techniques to produce efficient and semantically accurate C code.

---

##### 2.2.1. Mapping Constructs

##### **Key Constructs and Their Mappings**

##### **1. Variable Assignments**

* **Elixir**:  
  ```elixir
  x = 5
  ```
* **C**:  
  ```c
  int x = 5;
  ```
* **Explanation**:  
  The transpiler infers the variable type based on the assigned value and generates the appropriate C declaration and initialization.

##### **2. Function Calls**

* **Elixir**:  
  ```elixir
  IO.inspect(x)
  ```
* **C**:  
  ```c
  printf("%d \n", x);
  ```
* **Explanation**:  
  `IO.inspect` is mapped to C's `printf`, with format specifiers determined by the variable type.

##### **3. Anonymous Functions (`fn`)**

* **Elixir**:  
  ```elixir
  fn -> IO.inspect("Hello") end
  ```
* **C**:  
  ```c
  lambda(void, (void* arg), { printf("%s \n", "Hello"); })
  ```
* **Explanation**:  
  The transpiler uses the `lambda` macro (defined in `anonymous.h`) to create a function pointer in C, which can be passed to the runtime's thread creation function.

##### **4. Spawning Processes**

* **Elixir**:  
  ```elixir
  spawn(fn -> ... end)
  ```
* **C**:  
  ```c
  green_thread_create(lambda(void, (void* arg), { /* function body */ }), NULL);
  ```
* **Explanation**:  
  The `spawn` function is mapped to the runtime's `green_thread_create` function, which executes the provided anonymous function as a lambda expression.

##### **5. Concurrency Primitives**

* **Elixir**:  
  Lightweight processes managed by the BEAM VM.
* **C**:  
  * **Green Threads**:  
    Implemented using user-level threads managed by the custom scheduler.
  * **Message Passing** (if needed):  
    Can be emulated using shared data structures and synchronization mechanisms.

---

##### 2.2.2. Elixir’s `spawn` Mapped to C Runtime Functions (`green_thread_create`)

The `spawn` function in Elixir creates a lightweight process to execute a given function concurrently. In C, this is translated to the runtime's `green_thread_create` function, which integrates with the custom scheduler to manage green threads.

---

##### **Elixir `spawn` Usage**

<!-- livebook:{"force_markdown":true} -->

```elixir
spawn(fn -> IO.inspect("Hello, World!") end)
```

##### **Transpiled C Equivalent**

```c
green_thread_create(
    lambda(void, (void* arg), { printf("%s \n", "Hello, World!"); }), NULL);
```

---

##### **Explanation**

##### **1. Lambda Macro**

* **Purpose**:  
  The `lambda` macro (defined in `anonymous.h`) creates an anonymous function in C.
* **Parameters**:
  * Return type (e.g., `void`).
  * Argument list (e.g., `(void* arg)`).
  * Function body (e.g., `{ printf("%s \n", "Hello, World!"); }`).
* **Usage in Transpiled Code**:  
  Wraps the function body into a function pointer compatible with `green_thread_create`.

##### **2. `green_thread_create` Function**

* **Role**:  
  Initializes and creates a new green thread in the runtime environment.
* **Parameters**:
  * **Function Pointer**:  
    The lambda function created by the `lambda` macro.
  * **Argument (`arg`)**:  
    Typically `NULL` but can pass data to the thread function if needed.
* **Process**:
  * Allocates memory for the thread.
  * Initializes the thread's execution context.
  * Assigns the function pointer and argument.
  * Adds the thread to the scheduler's thread pool.

##### **3. Scheduler Integration**

* **Thread Management**:  
  The scheduler manages a pool of active green threads, tracking their states (`READY`, `RUNNING`, `FINISHED`) and executing them based on the scheduling algorithm (e.g., round-robin).
* **Context Switching**:  
  Uses `ucontext.h` functions (`getcontext`, `setcontext`, `swapcontext`) to switch between thread contexts.

---

##### **Runtime Lifecycle**

1. **Creation**:  
   When `green_thread_create` is called:

   * A new green thread is instantiated.
   * The thread is added to the scheduler's thread pool.

2. **Execution**:

   * The scheduler selects the new thread based on its `READY` state.
   * Executes the thread's function concurrently with other threads.

3. **Termination**:

   * After execution, the thread is marked as `FINISHED`.
   * The scheduler cleans up resources for the completed thread.

---

##### **Benefits of This Mapping**

1. **Efficiency**:  
   Green threads are lightweight compared to OS threads, enabling the creation of numerous concurrent tasks with minimal overhead.

2. **Control**:  
   The custom scheduler offers fine-grained control over thread execution, optimizing performance for specific applications.

3. **Portability**:  
   Abstracting concurrency mechanisms within the runtime ensures consistent behavior across platforms and environments.

---

<!-- livebook:{"break_markdown":true} -->

#### 2.3- Code generation techniques

Code generation is the phase where structured internal representations of Elixir code are translated into executable C code. This process involves converting high-level constructs into low-level instructions, managing type mappings, and ensuring the generated code adheres to C's syntax and semantics.

---

##### 2.3.1. AST-Based Code Traversal

##### **Process Overview**

1. **AST Traversal**:

   * The transpiler systematically navigates through the AST nodes.
   * Identifies different types of expressions like assignments, function calls, arithmetic operations, and concurrency primitives.

2. **Expression Handling**:

   * Matches each AST node against known patterns to determine its type and required translation.
   * For example:
     * Binary operations (`:+`, `:-`) are translated to their C equivalents.

3. **Context Management**:

   * Maintains a symbol table to track:
     * Variable declarations.
     * Types.
     * Scopes.
   * Ensures variables are declared with the correct types and used appropriately.

---

##### 2.3.2. Type Mappings and Inference

Elixir is dynamically typed, while C is statically typed. The transpiler bridges this gap using type inference to deduce appropriate C types based on the context and usage of variables.

##### **Key Type Mappings**

| Elixir Type            | C Type                                    |
| ---------------------- | ----------------------------------------- |
| `:integer_literal`     | `int`                                     |
| `:float_literal`       | `float`                                   |
| `:boolean_literal`     | `bool` or `int` (1 for true, 0 for false) |
| `:string_literal`      | `char*`                                   |
| `:varname` (variables) | Inferred based on context                 |

##### **Type Inference Example**

**Elixir Code**:

<!-- livebook:{"force_markdown":true} -->

```elixir
x = 5 + 3.2
```

**Inference Process**:

* `5`: Integer (`int`).
* `3.2`: Float (`float`).
* `:+`: Addition operation between `int` and `float` results in `float`.

**Generated C Code**:

```c
float x = 5 + 3.2;
```

---

##### 2.3.3. Macro Programming in C

To emulate Elixir's higher-order and anonymous functions, the transpiler uses macros and GCC-specific extensions like statement expressions.

##### **Lambda Macro**

**Definition** (from `anonymous.h`):

```c
#define lambda(lambda$_ret, lambda$_args, lambda$_body) \
  ({ \
    lambda$_ret lambda$__anon$ lambda$_args \
      lambda$_body \
    &lambda$__anon$; \
  })
```

##### **Components**

* **Return Type (`lambda$_ret`)**: Specifies the function's return type (e.g., `void`).
* **Arguments (`lambda$_args`)**: Defines the function's parameters (e.g., `(void* arg)`).
* **Body (`lambda$_body`)**: Contains the function's code (e.g., `{ printf("works"); }`).
* **Function Pointer**: Returns a pointer to the anonymous function.

##### **Example Usage**

```c
green_thread_create(
    lambda(void, (void* arg), { printf("%s \n", "Hello, World!"); }), NULL);
```

**Explanation**:

* Creates an anonymous function that prints "Hello, World!".
* Passes the function pointer to `green_thread_create` for execution within a green thread.

**Advantages**:

* **Emulates Higher-Order Functions**: Mimics Elixir's functional programming features.
* **Code Reusability**: Reduces the need for numerous named functions.

---

##### 2.3.4. Recursive Encoding of Expressions

Complex and nested expressions are translated recursively, ensuring all sub-expressions are processed correctly.

##### **Example**

**Elixir Code**:

<!-- livebook:{"force_markdown":true} -->

```elixir
x = (5 + 3) * 2
```

**AST Structure**:

<!-- livebook:{"force_markdown":true} -->

```elixir
{:assign, [context: Elixir, import: Kernel],
 [
   {:x, [context: Elixir], nil},
   {:*, [context: Elixir], [
     {:+, [context: Elixir], [5, 3]},
     2
   ]}
 ]}
```

**Transpilation Steps**:

1. **Assignment Parsing**:
   * Identifies the assignment to `x`.
2. **Multiplication Operation**:
   * Recognizes the `*` operator with operands `{:+, [context: Elixir], [5, 3]}` and `2`.
3. **Addition Operation**:
   * Parses the nested `+` operation as `5 + 3`.

**Generated C Code**:

```c
int x = (5 + 3) * 2;
```

**Implementation**:

* The `generate_code/1` function in `Transpiler.Tree.Expression` recursively:
  * Translates innermost expressions first.
  * Combines them with appropriate C operators.
  * Maintains precedence and parentheses.

---

##### 2.3.5. Handling Concurrency Constructs

Elixir's concurrency model is emulated in C using green threads managed by a custom scheduler.

##### **Key Concurrency Constructs**

##### **1. Spawning Threads**

* **Elixir**:
  ```elixir
  spawn(fn -> ... end)
  ```
* **C**:
  ```c
  green_thread_create(lambda(void, (void* arg), { /* function body */ }), NULL);
  ```
* **Explanation**:
  * Translates `spawn` to `green_thread_create`.
  * Encapsulates the function body in a lambda macro.

##### **2. Green Thread Execution**

**Runtime Function**:  
`green_thread_create`:

* Initializes a new green thread.
* Adds it to the scheduler's thread pool.

**Scheduler Management**:

* Tracks thread states (`READY`, `RUNNING`, `FINISHED`).
* Handles context switching using `swapcontext` and `setcontext`.

**Transpiled C Code**:

```c
green_thread_run();
```

**Explanation**:

* Starts the scheduler, which begins executing green threads based on its scheduling policy.

---

##### **Example**

**Elixir Code**:

<!-- livebook:{"force_markdown":true} -->

```elixir
spawn(fn -> IO.inspect("Hello from thread!") end)
```

**Transpiled C Code**:

```c
green_thread_create(
    lambda(void, (void* arg), { printf("%s \n", "Hello from thread!"); }), NULL);
```

**Runtime Execution Flow**:

1. **Thread Creation**:
   * `green_thread_create` initializes the thread's context and allocates a stack.
   * The lambda function is set as the execution function.
2. **Scheduling**:
   * The scheduler selects the thread based on its `READY` state.
   * Employs context switching to run the thread.
3. **Thread Execution**:
   * The thread's function prints "Hello from thread!".
   * After execution, the thread is marked `FINISHED` and cleaned up.

---

##### **Benefits**

1. **Lightweight Concurrency**:

   * Green threads are more efficient than OS threads, enabling scalable concurrency.

2. **Control Over Execution**:

   * The custom scheduler provides deterministic thread management.

3. **Scalability**:

   * Efficiently handles numerous concurrent tasks within the runtime.

---

## 3- Runtime

#### 3.1- Runtime Architecture:

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
graph TD
    subgraph User Input
        A[User-Defined Anonymous Function]
    end

    subgraph Greenthread Management
        B[Greenthread Creation and Wrapping Module]
        C[(Global Threads Array)]
    end

    subgraph Scheduling
        D[Scheduler]
        E[Round Robin Execution]
    end

    A -->|Creates and Wraps| B
    B -->|Thread 1| C
    B -->|Thread 2| C
    B -->|Thread 3| C
    B -->|...| C
    D -->|Schedule + Manage| C
    D -->|Executes| E

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#bbf,stroke:#333,stroke-width:2px,stroke-dasharray: 5 5
    style C fill:#bef,stroke:#333,stroke-width:2px
    style D fill:#fbb,stroke:#333,stroke-width:2px
    style E fill:#ffb,stroke:#333,stroke-width:2px

```

<!-- livebook:{"break_markdown":true} -->

#### Description

##### 1. Scheduler (Preemptive Multitasking)

* **Objective:** Manage the execution of multiple greenthreads by allocating CPU time slices, ensuring that each thread progresses without manual intervention.

* **Functionality:**

  * **Preemptive Scheduling:** The scheduler autonomously interrupts running threads after a predefined time slice, allowing other threads to execute. This ensures fair CPU time distribution and prevents any single thread from monopolizing system resources.
  * **Context Switching:** Efficiently switches the execution context between threads, maintaining the state of each thread to resume execution seamlessly.
  * **Load Balancing:** Dynamically adjusts scheduling policies based on the current workload and thread priorities to optimize performance.

* **Integration in Diagram:**
  Represented by the Scheduler node, which interacts with the Global Threads Array to manage thread execution and employs Round Robin Execution as its scheduling strategy.

##### 2. Greenthreads as Lightweight Processes

* **Objective:** Provide a mechanism for concurrent execution within the C runtime, mimicking the lightweight processes found in higher-level languages like Elixir.

* **Characteristics:**

  * **Lightweight:** Greenthreads consume minimal system resources compared to traditional OS threads, allowing the creation of a large number of concurrent threads without significant overhead.
  * **User-Space Management:** Managed entirely in user space without kernel intervention, enabling faster context switches and reduced latency.
  * **Isolation:** Each greenthread operates independently, preventing faults in one thread from affecting others, thereby enhancing fault tolerance.

* **Functionality:**

  * **Creation and Wrapping:** User-defined anonymous functions are encapsulated into greenthreads by the Greenthread Creation and Wrapping Module.
  * **Execution:** Once created, greenthreads are stored in the Global Threads Array for the scheduler to manage their execution.

* **Integration in Diagram:**
  Represented by the User-Defined Anonymous Function node creating and being wrapped by the Greenthread Creation and Wrapping Module, which then populates the Global Threads Array with individual greenthreads (e.g., Thread 1, Thread 2, Thread 3, etc.).

##### 3. Threads Array for Execution Management

* **Objective:** Maintain and organize all active greenthreads, facilitating efficient scheduling and execution management.

* **Components:**

  * **Global Threads Array:** A centralized data structure that holds references to all active greenthreads. It enables the scheduler to iterate through available threads, manage their states, and perform scheduling operations.
  * **Thread States:** Each entry in the array maintains the state of a greenthread (e.g., running, ready, blocked), allowing the scheduler to make informed decisions about thread execution.

* **Functionality:**

  * **Registration:** New greenthreads are added to the array upon creation, ensuring they are tracked and managed effectively.
  * **Management:** The scheduler accesses the array to select the next thread to execute based on the scheduling algorithm (e.g., Round Robin).
  * **Cleanup:** Completed or terminated threads are removed from the array, freeing up resources and maintaining optimal performance.

* **Integration in Diagram:**
  Represented by the Global Threads Array node, which receives multiple threads (Thread 1, Thread 2, Thread 3, etc.) from the Greenthread Creation and Wrapping Module and is managed by the Scheduler node.

#### Overall Workflow

* **User-Defined Anonymous Function Creation:**

  * Users define anonymous functions in Elixir, which are translated into C code and provided as input to the runtime system.

* **Greenthread Creation and Wrapping:**

  * The Greenthread Creation and Wrapping Module takes these anonymous functions and encapsulates them into greenthreads, adding them to the Global Threads Array for management.

* **Scheduling and Execution:**

  * The Scheduler employs a Round Robin Execution strategy to preemptively manage and execute greenthreads. It iterates through the Global Threads Array, allocating CPU time slices to each active greenthread.
  * Round Robin Execution ensures that each greenthread receives an equal opportunity to execute, promoting fairness and preventing starvation.

* **Concurrency and Fault Tolerance:**

  * By utilizing greenthreads, the runtime enables concurrent execution of multiple lightweight processes within a single OS thread. This design enhances fault tolerance, as failures in individual greenthreads do not impact the entire system.

* **Output Generation:**

  * The scheduler oversees the execution of greenthreads, ensuring that the translated C code runs efficiently and maintains the concurrency model originally defined in Elixir.

<!-- livebook:{"break_markdown":true} -->

#### 3.2- Concurrency Model:

<!-- livebook:{"break_markdown":true} -->

##### Preemptive Scheduling (Round-Robin Policy)

* **Objective:**
  To manage multiple greenthreads efficiently by ensuring each thread receives an equitable share of CPU time without requiring manual intervention.

* **Functionality:**

  * **Round-Robin Scheduling:**
    * Implements a simple yet effective scheduling algorithm where each greenthread is assigned a fixed time slice in a cyclic order.
    * The Scheduler iterates through the Global Threads Array, allocating CPU time to each active greenthread sequentially.
    * **Preemption:**
        The scheduler can interrupt a running greenthread once its time slice expires, allowing the next greenthread in the queue to execute. This prevents any single thread from monopolizing the CPU.

* **Integration in Architecture:**

* **Scheduler Node:** Utilizes the Round Robin Execution strategy to manage and execute greenthreads stored in the Global Threads Array.

* **Greenthread Management Module:** Ensures that greenthreads are appropriately created, wrapped, and registered in the threads array for the scheduler to manage.

##### Isolated Heaps

* **Objective:**
  To enhance memory safety and fault isolation by ensuring that each greenthread operates within its own memory space.

* **Functionality:**

  * **Memory Isolation:**
    Each greenthread is allocated a separate heap, preventing one thread from inadvertently accessing or modifying another thread's memory.
    This isolation is crucial for maintaining data integrity and preventing race conditions.
  * **Garbage Collection:**
    Individual heaps allow for more efficient memory management and garbage collection, as memory can be reclaimed on a per-thread basis without affecting others.

* **Integration in Architecture:**
  Greenthread Creation and Wrapping Module: Allocates and manages isolated heaps during the creation of each greenthread.

* **Scheduler:** Interacts with the isolated heaps indirectly by managing thread execution without direct interference in their memory spaces.

##### Benefits

* **High Scalability:**

  * **Lightweight Nature of Greenthreads:**
    Greenthreads consume minimal system resources compared to traditional OS threads, allowing the runtime to handle thousands of concurrent threads without significant performance degradation.
  * **Efficient Scheduling:**
    The round-robin policy ensures balanced CPU time distribution, enabling the system to scale effectively with increasing workloads.

* **Fault Isolation:**

  * **Isolated Heaps:**
    Prevents faults in one greenthread from propagating to others, enhancing the overall robustness of the system.
  * **Independent Execution:**
    Each greenthread operates independently, ensuring that a failure in one does not impact the execution of others.

##### Limitations

* **Overhead in Context Switching:**

  * **Frequency of Preemption:**
    Although greenthreads are lightweight, frequent context switches due to preemptive scheduling can introduce overhead, potentially affecting performance.
  * **Scheduler Complexity:**
    Managing a large number of greenthreads and performing efficient context switches require a well-optimized scheduler to minimize latency and overhead.

* **Memory Management Complexity:**

  * **Isolated Heaps:**
    Allocating and managing separate heaps for each greenthread increases the complexity of memory management within the runtime.
  * **Potential Fragmentation:**
    Without careful handling, isolated heaps can lead to memory fragmentation, reducing overall memory efficiency.

<!-- livebook:{"break_markdown":true} -->

#### 3.3- Fault Tolerance:

<!-- livebook:{"break_markdown":true} -->

##### Philosophy: "Let it Crash."

* **Objective:**
  Embrace a robust fault tolerance strategy where individual greenthreads are allowed to fail without compromising the stability of the entire system.

* **Philosophy Explanation:**

  * **"Let it Crash"**:
    Inspired by Erlang/Elixir's fault-tolerance paradigm, this approach accepts that errors and crashes are inevitable in concurrent systems.
    Instead of attempting to prevent all errors, the system is designed to handle failures gracefully, ensuring that they do not cascade and cause widespread system instability.

##### Implementation: Execution Never Falls Down

* **Objective:**
  Ensure that the runtime remains operational and continues executing other greenthreads even if one or more threads encounter a failure.

* **Functionality:**

  * **Error Handling Mechanisms:**
    Implement robust error detection and handling within each greenthread to catch and manage exceptions without affecting other threads.
  * **Isolation via Isolated Heaps:**
    As previously described, isolated heaps ensure that a fault in one thread does not corrupt the memory space of others, maintaining overall system integrity.
  * **Watchdog Components:**
    Integrate watchdog mechanisms within the Scheduler to monitor the health of greenthreads and take corrective actions if a thread becomes unresponsive or crashes.

* **Integration in Architecture:**

  * **Scheduler:** Continuously monitors greenthread states and ensures that the failure of one does not halt the execution of others.
  * **Greenthread Management Module:** Facilitates the creation and isolation of greenthreads, making it easier to handle individual thread failures without impacting the entire system.

##### Integration with Previous Work

Concurrency and Fault Tolerance in the Runtime Architecture

The Concurrency Model and Fault Tolerance components are integral to the Runtime Architecture previously described. Here's how they seamlessly integrate with the existing components:

* **Greenthread Management Module:**

  * **Concurrency:** Responsible for creating and wrapping user-defined anonymous functions into greenthreads, ensuring each thread has an isolated heap.
  * **Fault Tolerance:** Prepares greenthreads for isolation, facilitating independent execution and failure management.

* **Global Threads Array:**

  * **Concurrency:** Acts as the central repository for all active greenthreads, enabling the scheduler to manage their execution effectively.
  * **Fault Tolerance:** Allows the scheduler to monitor and manage the state of each greenthread, ensuring that failures are contained and do not disrupt the entire system.

* **Scheduler:**

  * **Concurrency:** Implements the preemptive round-robin scheduling policy to manage the execution of greenthreads.
  * **Fault Tolerance:** Monitors greenthread health and ensures that execution continues smoothly even if individual threads fail.

* **Round Robin Execution:**

  * **Concurrency:** Ensures fair and efficient CPU time distribution among greenthreads.
  * **Fault Tolerance:** Works in tandem with fault tolerance mechanisms to maintain system stability despite individual thread failures.

##### Future Improvements: Supervisor Trees & Dynamic Supervisor Strategies

* **Objective:**
  Enhance the fault tolerance capabilities of the runtime by introducing hierarchical supervision and dynamic strategies for managing greenthread failures.

* **Future Enhancements:**

  * **Supervisor Trees:**
    * Hierarchical Supervision:
      * Organize greenthreads into a tree-like structure where supervisors oversee one or more worker threads.
      * Supervisors are responsible for monitoring their child threads and restarting them in case of failures.

* **Benefits:**

  * **Modular Fault Management:**
    * Isolates faults within specific branches of the supervisor tree, preventing failures from propagating across unrelated parts of the system.
  * **Scalability:**
    * Facilitates scalable fault management as the system grows, with supervisors managing subsets of greenthreads.

* **Dynamic Supervisor Strategies:**

  * **Adaptive Fault Handling:**
    Implement strategies that dynamically adjust how supervisors handle failures based on runtime conditions and thread behaviors.
  * **Examples of Strategies:**
    * **One-for-One:**
      Restart only the failed greenthread.
    * **One-for-All:**
      Restart all greenthreads under a supervisor if one fails.
    * **Rest-for-One:**
      Restart the failed greenthread and any threads started after it.
  * **Benefits:**
    * **Flexibility:**
      Allows the system to adapt to different fault scenarios, optimizing recovery processes based on the nature and severity of failures.
    * **Resilience:**
      Enhances the system's ability to recover from a wide range of faults, maintaining high availability and reliability.

* **Integration in Architecture:**

  * **Supervisor Modules:**
    Introduce dedicated modules responsible for implementing supervisor trees and dynamic strategies.
  * **Enhanced Scheduler:**
    The scheduler interacts with supervisor modules to manage the lifecycle of greenthreads, incorporating supervision logic into the scheduling process.

<!-- livebook:{"break_markdown":true} -->

#### 3.4- Performance Considerations:

<!-- livebook:{"break_markdown":true} -->

* **Overheads:** Managing thread pools.

<!-- livebook:{"break_markdown":true} -->

### 4- Code Walkthrough

<!-- livebook:{"break_markdown":true} -->

#### 4.1- Elixir Compilation

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
flowchart LR
      EE[Elixir Raw Code]
      F[Ast Generator]
    subgraph Transpiler
      EE -->| Parsing into AST| F --> |Yielding valid Elixir Statements|D
   
    subgraph Modules
        A[Transpiler.Tree.Expression]
        B[Transpiler.Tree.Mainblock]
        C[Transpiler.CodeGenerator]
    end

        D[Elixir Statements] -->|Encodes Recursively| A
        A -->|Encoded Expressions into MainBlock| B
        B -->|MainBlocks Fed into| C
        
      C -->|Generates C Output| E[C Code]
     end

  

```

<!-- livebook:{"break_markdown":true} -->

##### Component Breakdown

* **1. Elixir Raw Code**

  * **Description:**
    * Represents the original Elixir source code that the user inputs into the transpiler.
  * **Role in Transpilation:**
    * Serves as the starting point for the transpilation process, containing all the functions, modules, and expressions that need to be converted into C.

* **2. AST Generator**

  * **Description:**
    * A module responsible for parsing the raw Elixir code and generating its Abstract Syntax Tree (AST).
  * **Functionality:**
    * **Parsing:** Analyzes the syntactic structure of the Elixir code to create a hierarchical tree representation (AST) that captures the grammatical structure of the code.
    * **Yielding Elixir Statements:** Transforms the AST into a sequence of valid Elixir statements that can be further processed by subsequent modules.
  * **Integration:**
    Connects directly to the Elixir Raw Code node, receiving the raw code and outputting parsed Elixir statements.

* **3. Elixir Statements**

  * **Description:**
    * Intermediate representation of the parsed Elixir code, structured as individual statements extracted from the AST.
  * **Role in Transpilation:**
    -Acts as the input for the recursive encoding process, breaking down complex expressions into manageable components for translation into C.

* **4. Modules Overview**

The Transpiler comprises several specialized modules, each handling different aspects of the code translation process:

* **a. Transpiler.Tree.Expression**
  * **Description:**

Manages the encoding of individual Elixir expressions.

* **Functionality:**
  * **Recursive Encoding:** Processes each Elixir expression recursively, ensuring that nested and complex expressions are accurately translated into their C equivalents.
  * **Expression Mapping:** Utilizes predefined type mappings and translation rules to convert Elixir expressions into C-compatible constructs.
* **Integration:**
  * Receives Elixir statements from the Elixir Statements node and outputs encoded expressions to the Transpiler.Tree.Mainblock module.

* **b. Transpiler.Tree.Mainblock**

  * **Description:**
    Organizes encoded expressions into coherent main blocks suitable for C code generation.
  * **Functionality:**
    * **Main Block Assembly:** Aggregates encoded expressions into main blocks, maintaining the logical flow and structure required for valid C code.
    * **Context Preservation:** Ensures that the context and scope of each expression are preserved during the translation process.
  * **Integration:**
    Receives encoded expressions from Transpiler.Tree.Expression and forwards assembled main blocks to the Transpiler.CodeGenerator module.

* **c. Transpiler.CodeGenerator**

  * **Description:**
    The final module responsible for generating the target C code from the assembled main blocks.
  * **Functionality:**
    * **Code Generation:** Converts the structured main blocks into syntactically correct and optimized C code.
    * **Output Formatting:** Ensures that the generated C code adheres to standard formatting conventions, enhancing readability and maintainability.
  * **Integration:**
    Receives main blocks from Transpiler.Tree.Mainblock and outputs the final C Code.

* **5. C Code**

  * **Description:**
    The final output of the transpilation process, representing the Elixir code translated into C.
  * **Role in Project:**
    Provides a C-equivalent version of the original Elixir code, ready for compilation and execution within the C runtime environment that supports concurrency and fault tolerance.

##### Workflow Overview

* **Input Elixir Code:**

  * Users provide raw Elixir code (EE) to the transpiler.

* **AST Generation:**

  * The AST Generator (F) parses the raw code, generating an Abstract Syntax Tree (AST) and yielding valid Elixir statements (D).

* **Recursive Encoding:**

  * Transpiler.Tree.Expression (A) encodes each Elixir statement recursively, handling complex and nested expressions.

* **Main Block Assembly:**

  * Encoded expressions are organized into main blocks by Transpiler.Tree.Mainblock (B), maintaining the logical structure necessary for valid C code.

* **C Code Generation:**

  * Transpiler.CodeGenerator (C) converts the assembled main blocks into well-formatted C code (E).

* **Output Delivery:**

  * The final C Code is produced, mirroring the functionality of the original Elixir code and ready for execution within the optimized C runtime environment.

##### Benefits of This Transpiler Architecture

* **Modular Design:**

  * Each module within the transpiler handles a specific aspect of the translation process, promoting maintainability and scalability.

* **Recursive Encoding:**

  * Allows for the accurate translation of complex and nested Elixir expressions into C, ensuring functional parity between the source and target code.

* **Type Safety:**

  * Utilizes predefined type mappings to maintain C’s strict typing system, preventing type-related errors during compilation and execution.

* **Seamless Integration:**

  * The generated C code is optimized for compatibility with the runtime environment, facilitating efficient execution of concurrent and fault-tolerant operations.

* **Extensibility:**

  * The modular approach enables easy addition of new translation rules and support for additional Elixir features, enhancing the transpiler’s capabilities over time.

<!-- livebook:{"break_markdown":true} -->

##### Detailed Code Explanation and Task Overview

<!-- livebook:{"break_markdown":true} -->

##### 1. Transpiler Module (transpiler.ex)

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Transpiler do

  @spec transpile(binary(), atom()) :: {:ok, term()}
  def transpile(elixir_code, type \\ :binary)

  @spec transpile(binary(), atom()) :: {:ok, term()}
  def transpile(path, :file) do
    with {:ok, elixir_code} <- File.read(path) do
      transpile(elixir_code, :binary)
    end
  end

  @spec transpile(binary(), atom()) :: {:ok, term()}
  def transpile(elixir_code, :binary) do
    output =
      elixir_code
      |> Code.string_to_quoted!()
      |> Transpiler.Parser.parse()
      |> Transpiler.CodeGenerator.generate_code()

    {:ok, output}
  end
end
```

<!-- livebook:{"break_markdown":true} -->

###### Task and Functionality:

* **Purpose:**
  Acts as the central orchestrator for the transpilation process, handling both file-based and binary (in-memory) Elixir code inputs and producing the corresponding C code output.

**Functions:**

* transpile/2 (Default Binary Input):

  * Signature: @spec transpile(binary(), atom()) :: {:ok, term()}

  * Parameters:

    * elixir_code: The raw Elixir code as a binary string.
    * type: Specifies the input type, defaulting to :binary.

  * Process:
    Converts the Elixir code string into an Abstract Syntax Tree (AST) using Code.string_to_quoted!().
    Parses the AST into a structured internal representation using Transpiler.Parser.parse().
    Generates the equivalent C code from the parsed structure via Transpiler.CodeGenerator.generate_code().

  * Output:
    Returns a tuple {:ok, output} where output is the generated C code.

* transpile/2 (File Input):

  * Signature: @spec transpile(binary(), atom()) :: {:ok, term()}
  * Parameters:
    * path: File path to the Elixir source code.
    * type: Set to :file to indicate file-based input.
  * Process:
    Reads the Elixir code from the specified file using File.read(path).
    On successful read, delegates to the binary input transpile/2 function to process the code.
  * Error Handling:
    Utilizes the with construct to gracefully handle file read errors, propagating them upwards.

##### Integration in the Transpilation Pipeline:

* Input:
  Receives Elixir code either as a file path or as a binary string.

* Processing:
  Converts Elixir code into an AST, parses it into a structured format, and generates the corresponding C code.

* Output:
  Produces the transpiled C code, encapsulated in an {:ok, output} tuple for successful execution or an error tuple in case of failures.

<!-- livebook:{"break_markdown":true} -->

##### 2. Parser Module (parse.ex)

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Transpiler.Parser do

  @spec parse(
          {:__block__, any(),
           [
             %Transpiler.Tree.Expression{}
           ]}
        ) ::
          %Transpiler.Tree.MainBlock{}
  def parse({:__block__, _meta, expressions}) do
    Transpiler.Tree.MainBlock.parse(expressions)
  end

  @spec parse(%Transpiler.Tree.Expression{}) :: %Transpiler.Tree.MainBlock{}
  def parse(single_expression) do
    Transpiler.Tree.MainBlock.parse([single_expression])
  end
end

```

<!-- livebook:{"break_markdown":true} -->

#### Task and Functionality

* Purpose
  Converts the Elixir AST into a `Transpiler.Tree.MainBlock` structure, which serves as an intermediate representation for code generation.

---

* Functions
  * `parse/1` (Block Parsing)

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse(
  {:__block__, any(),
   [
     %Transpiler.Tree.Expression{}
   ]}
) ::
  %Transpiler.Tree.MainBlock{}
```

* **Parameters**:  
  An Elixir AST node representing a block of expressions (`{:__block__, _meta, expressions}`).

* **Process**:  
  Delegates the list of expressions to `Transpiler.Tree.MainBlock.parse/1` for further parsing.

* **Output**:  
  Returns a `%Transpiler.Tree.MainBlock{}` struct containing the parsed expressions.

---

* `parse/1` (Single Expression Parsing)
  * **Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse(%Transpiler.Tree.Expression{}) :: %Transpiler.Tree.MainBlock{}
```

* **Parameters**:  
  A single `%Transpiler.Tree.Expression{}` struct representing an individual expression.

* **Process**:  
  Wraps the single expression in a list and delegates it to `Transpiler.Tree.MainBlock.parse/1`.

* **Output**:  
  Returns a `%Transpiler.Tree.MainBlock{}` struct containing the single parsed expression.

---

##### Integration in the Transpilation Pipeline

* **Input**:  
  Receives Elixir AST nodes either as a block (`{:__block__, ...}`) or as single expressions.

* **Processing**:  
  Converts these AST nodes into structured `MainBlock` representations, facilitating organized code generation.

* **Output**:  
  Produces a `%Transpiler.Tree.MainBlock{}` struct that encapsulates all expressions within a main block, ready for C code generation.

<!-- livebook:{"break_markdown":true} -->

##### 3. Command-Line Interface Module (cli.ex)

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Transpiler.CLI do
  def main(args) do
    args
    |> parse_args()
    |> process()
  end

  defp parse_args(args) do
    {opts, _word, _} =
      OptionParser.parse(args,
        strict: [
          input: :string,
          output: :string
        ],
        aliases: [
          i: :input,
          o: :output
        ]
      )

    raise_on_missing_arg(opts, :input)
    raise_on_missing_arg(opts, :output)
    opts
  end

  defp raise_on_missing_arg(opts, arg) do
    if not Keyword.has_key?(opts, arg) do
      raise OptionParser.ParseError.exception("Missing argument: #{arg}")
    end
  end

  defp process(opts) do
    with {:ok, output} <- Transpiler.transpile(opts[:input], :file),
         :ok <- write_c_folder(opts[:output], output) do
      IO.puts("Successfully transpiled!")
    else
      {:error, error} ->
        IO.puts(:stderr, error)
    end
  end

  defp write_c_folder(path, content) do
    with :ok <- File.mkdir_p(path) do
      path
      |> Path.join("main.c")
      |> File.write(content)
    end
  end
end

```

<!-- livebook:{"break_markdown":true} -->

##### Task and Functionality

##### Purpose

Provides a command-line interface (CLI) for users to interact with the transpiler, allowing them to specify input Elixir code and output directories for the generated C code.

---

##### Functions

##### `main/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
def main(args)
```

* **Parameters**:  
  `args`: List of command-line arguments.

* **Process**:

  * Pipes the arguments through `parse_args/1` to extract options.
  * Passes the parsed options to `process/1` to execute the transpilation.

* **Output**:  
  Executes the transpilation process and outputs success or error messages to the console.

---

##### `parse_args/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
defp parse_args(args)
```

* **Parameters**:  
  `args`: List of command-line arguments.

* **Process**:

  * Utilizes `OptionParser.parse/2` to extract `:input` and `:output` options.
  * Supports both long (`--input`, `--output`) and short (`-i`, `-o`) aliases.
  * Raises a `ParseError` if either `:input` or `:output` is missing.

* **Output**:  
  Returns a keyword list containing the parsed options.

---

##### `raise_on_missing_arg/2`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
defp raise_on_missing_arg(opts, arg)
```

* **Parameters**:

  * `opts`: Keyword list of parsed options.
  * `arg`: The required argument to check (`:input` or `:output`).

* **Process**:

  * Checks if the specified `arg` exists in `opts`.
  * Raises a `ParseError` if the `arg` is missing.

* **Output**:  
  Raises an exception if the required argument is absent.

---

##### `process/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
defp process(opts)
```

* **Parameters**:  
  `opts`: Keyword list containing `:input` and `:output` paths.

* **Process**:

  * Calls `Transpiler.transpile/2` with the input path to generate C code.
  * Writes the generated C code to the specified output directory using `write_c_folder/2`.
  * Outputs a success message upon successful transpilation.
  * Handles and outputs errors encountered during transpilation or file writing.

* **Output**:  
  Prints `"Successfully transpiled!"` on success or error messages on failure.

---

##### `write_c_folder/2`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
defp write_c_folder(path, content)
```

* **Parameters**:

  * `path`: Output directory path.
  * `content`: Generated C code as a binary string.

* **Process**:

  * Creates the output directory if it doesn't exist using `File.mkdir_p/1`.
  * Writes the C code to a file named `main.c` within the output directory.

* **Output**:  
  Returns `:ok` on success or an error tuple if file operations fail.

---

##### Integration in the Transpilation Pipeline

* **Input**:  
  Accepts Elixir code either as a file path (`--input` or `-i`) and an output directory path (`--output` or `-o`).

* **Processing**:  
  Orchestrates the transpilation by invoking the `Transpiler.transpile/2` function and manages the output file generation.

* **Output**:  
  Generates a `main.c` file containing the transpiled C code in the specified output directory, notifying the user upon successful completion or error occurrences.

<!-- livebook:{"break_markdown":true} -->

#### 4. Expression Parsing Module (Transpiler.Tree.Expression.ex)

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Transpiler.Tree.Expression do
  defstruct [:arguments, :type, :return_type, :context]

  @type ast_elementary_ops() :: :+ | :- | :* | :/ | :< | :> | :== | :!= | :&& | :||
  @type ast_elementary_ops_with_assigment() :: ast_elementary_ops() | :=
  @type ast_elementary_funs() :: :spawn | :fn | nil
  @type literal_type() :: :integer_literal | :float_literal | :boolean_literal | :string_literal

  # arguments are sub-expressions
  # type can be :+, :-, :*, :/, :<, :>, :==, :!=, :&&, :||, :!, :assign, :print
  # return_type can be :int, :float, :bool, :string, :list, :function, :nil

  @spec parse({ast_elementary_ops(), term(), [integer()]}, map()) :: %Transpiler.Tree.Expression{}
  def parse({operator, _meta, [left, right]}, context)
      when operator in [:+, :-, :*, :/, :<, :>, :==, :!=, :&&, :||] do
    right_expr = parse(right, context)
    left_expr = parse(left, context)

    %__MODULE__{
      arguments: [left_expr, right_expr],
      type: operator,
      return_type: infer_return_type(operator, right_expr.return_type, left_expr.return_type),
      context: context
    }
  end

  @spec parse({ast_elementary_ops_with_assigment(), term(), [term()]}, map()) ::
          {%Transpiler.Tree.Expression{}, map()}
  def parse({:=, _meta, [{varname, _, nil}, right]}, context) do
    right_expr = parse(right, context)

    {%__MODULE__{
       arguments: [varname, right_expr],
       type: :assign,
       return_type: right_expr.return_type,
       ## why ?
       context: context
     }, Map.put(context, varname, right_expr)}
  end

  @spec parse(ast_elementary_ops(), String.t()) :: {%Transpiler.Tree.Expression{}, map()}
  def parse(
        {{:., _, [{:__aliases__, _, [:IO]}, :inspect]}, _, [arg]},
        context
      ) do
    %__MODULE__{
      arguments: [parse(arg, context)],
      type: :print,
      return_type: :void,
      context: context
    }
  end

  # Experimental , creating fun clause
  @spec parse({ast_elementary_funs(), any(), [any()]}, map()) :: %Transpiler.Tree.Expression{}
  def parse(
        {:spawn, _, arg_for_spawn},
        context
      ) do
    {:fn, _, [{:->, _, [_, block_element]}]} = hd(arg_for_spawn)

    %__MODULE__{
      arguments: %{args: Transpiler.Parser.parse(block_element)},
      type: :spawn,
      return_type: :void,
      context: context
    }
  end

  @spec parse({atom(), term(), nil}, map()) :: {%Transpiler.Tree.Expression{}, map()}
  def parse({varname, _meta, nil}, context) do
    %__MODULE__{
      arguments: [varname],
      type: :varname,
      return_type: context[varname].return_type,
      context: context
    }
  end

  @spec parse({atom(), term(), nil}, map()) :: {%Transpiler.Tree.Expression{}, map()}
  def parse(value, context) when is_integer(value) do
    %__MODULE__{
      arguments: [value],
      type: :integer_literal,
      return_type: :int,
      context: context
    }
  end

  @spec parse(float(), map()) :: %Transpiler.Tree.Expression{}
  def parse(value, context) when is_float(value) do
    %__MODULE__{
      arguments: [value],
      type: :float_literal,
      return_type: :float,
      context: context
    }
  end

  @spec parse(bool(), map()) :: %Transpiler.Tree.Expression{}
  def parse(value, context) when is_boolean(value) do
    %__MODULE__{
      arguments: [value],
      type: :boolean_literal,
      return_type: :bool,
      context: context
    }
  end

  @spec parse(binary(), map()) :: %Transpiler.Tree.Expression{}
  def parse(value, context) when is_binary(value) do
    %__MODULE__{
      arguments: [value],
      type: :string_literal,
      return_type: :string,
      context: context
    }
  end

  @spec parse_anonymous_fun_content([%Transpiler.Tree.Expression{}]) :: nonempty_binary()
  defp parse_anonymous_fun_content(anonymous_function_block) do
    "while (1) {#{Enum.map_join(anonymous_function_block.expressions, "    ;\n            ", &Transpiler.Tree.Expression.generate_code(&1))};} \n"
  end

  @spec generate_code(%Transpiler.Tree.Expression{type: :print, arguments: []}) :: String.t()
  def generate_code(%__MODULE__{type: :print, arguments: [value]}) do
    format_string =
      case value.return_type do
        :int -> "%d"
        :float -> "%f"
        :bool -> "%d"
        :string -> "%s"
      end

    ~s[printf("#{format_string} \\n", #{generate_code(value)})]
  end

  # TODO

  @spec generate_code(%Transpiler.Tree.Expression{type: :spawn, arguments: []}) :: String.t()
  def generate_code(%__MODULE__{type: :spawn, arguments: %{args: value}}) do
    ~s[green_thread_create(\n        lambda(void, (void* arg), { \n            #{parse_anonymous_fun_content(value)} }), NULL)]
  end

  @spec generate_code(%Transpiler.Tree.Expression{type: :assign, arguments: [any()]}) ::
          String.t()
  def generate_code(%__MODULE__{type: :assign, arguments: [varname, right_expr]}) do
    type_keyword =
      case right_expr.return_type do
        :int -> "int"
        :float -> "float"
        :bool -> "char"
        :string -> "char*"
      end

    "#{type_keyword} #{varname} = #{generate_code(right_expr)}"
  end

  @spec generate_code(%Transpiler.Tree.Expression{type: literal_type(), arguments: [any()]}) ::
          binary()
  def generate_code(%__MODULE__{type: type, arguments: [value]})
      when type in [:integer_literal, :float_literal, :boolean_literal] do
    "#{value}"
  end

  @spec generate_code(%Transpiler.Tree.Expression{type: :string_literal, arguments: [any()]}) ::
          String.t()
  def generate_code(%__MODULE__{type: :string_literal, arguments: [value]}) do
    ~s["#{value}"]
  end

  @spec generate_code(%Transpiler.Tree.Expression{type: :varname, arguments: [any()]}) ::
          String.t()
  def generate_code(%__MODULE__{type: :varname, arguments: [varname]}) do
    "#{varname}"
  end

  @spec generate_code(%Transpiler.Tree.Expression{}) :: String.t()
  def generate_code(expression) do
    [arg1, arg2] = expression.arguments

    case expression.type do
      :+ -> "#{generate_code(arg1)} + #{generate_code(arg2)}"
      :- -> "#{generate_code(arg1)} - #{generate_code(arg2)}"
      :* -> "(#{generate_code(arg1)}) * (#{generate_code(arg2)})"
      :/ -> "(#{generate_code(arg1)}) / (#{generate_code(arg2)})"
      :< -> "(#{generate_code(arg1)}) < (#{generate_code(arg2)})"
      :> -> "(#{generate_code(arg1)}) > (#{generate_code(arg2)})"
      :== -> "(#{generate_code(arg1)}) == (#{generate_code(arg2)})"
      :!= -> "(#{generate_code(arg1)}) != (#{generate_code(arg2)})"
      :&& -> "(#{generate_code(arg1)}) && (#{generate_code(arg2)})"
      :|| -> "(#{generate_code(arg1)}) || (#{generate_code(arg2)})"
      :assign -> "int #{arg1} = #{generate_code(arg2)}"
    end
  end

  # till we can standardize this types
  @typedoc """
  Temporary (or partial) types used for inference in arithmetic and logical operations.
  Can be `:float`, `:int`, `:bool`, or an `atom()` placeholder.
  """
  @type temp_types() :: :float | :int | :bool | atom()

  @spec infer_return_type(ast_elementary_ops(), temp_types(), temp_types()) :: temp_types()
  defp infer_return_type(operator, left_type, right_type) when operator in [:+, :-, :*, :/] do
    if left_type == :float or right_type == :float do
      :float
    else
      :int
    end
  end

  @spec infer_return_type(ast_elementary_ops(), any(), any()) :: temp_types()
  defp infer_return_type(operator, _, _) when operator in [:<, :>, :==, :!=, :&&, :||], do: :bool
end

```

<!-- livebook:{"break_markdown":true} -->

##### Task and Functionality

##### Purpose

Parses individual Elixir expressions from the AST and converts them into a structured `Transpiler.Tree.Expression` format, which can then be translated into C code.

---

##### Data Structures

##### `%Transpiler.Tree.Expression{}` Struct

**Fields**:

* `:arguments`: List of sub-expressions or operands.
* `:type`: The operation type (e.g., `:+`, `:-`, `:assign`).
* `:return_type`: The inferred return type (e.g., `:int`, `:float`, `:bool`).
* `:context`: Contextual information, such as variable bindings.

---

##### Functions

##### `parse/2` (Binary Operations)

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse({ast_elementary_ops(), term(), [integer()]}, map()) :: %Transpiler.Tree.Expression{}
```

* **Parameters**:

  * A tuple representing a binary operation (e.g., `:+`, `:-`).
  * `context`: A map containing variable bindings and other contextual information.

* **Process**:

  * Recursively parses the left and right operands.
  * Constructs a `%Transpiler.Tree.Expression{}` with the operation type and inferred return type.

* **Example**:

  * **Elixir**: `x + y`
  * **C**: `x + y`

---

##### `parse/2` (Assignment Operation)

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse({ast_elementary_ops_with_assignment(), term(), [term()]}, map()) ::
      {%Transpiler.Tree.Expression{}, map()}
```

* **Parameters**:

  * A tuple representing an assignment operation (e.g., `x = 5`).
  * `context`: Current variable bindings.

* **Process**:

  * Parses the right-hand side expression.
  * Constructs a `%Transpiler.Tree.Expression{}` for the assignment.
  * Updates the context with the new variable binding.

* **Output**:  
  Returns a tuple containing the assignment expression and the updated context.

* **Example**:

  * **Elixir**: `x = 5`
  * **C**: `int x = 5;`

---

##### `parse/2` (Print Operation)

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse(ast_elementary_ops(), String.t()) :: {%Transpiler.Tree.Expression{}, map()}
```

* **Parameters**:

  * A tuple representing a print operation (e.g., `IO.inspect(x)`).
  * `context`: Current variable bindings.

* **Process**:

  * Parses the argument to be printed.
  * Constructs a `%Transpiler.Tree.Expression{}` with type `:print` and return type `:void`.

* **Example**:

  * **Elixir**: `IO.inspect(x)`
  * **C**: `printf("%d \n", x);`

---

##### `parse/2` (Spawn Operation)

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse({ast_elementary_funs(), any(), [any()]}, map()) :: %Transpiler.Tree.Expression{}
```

* **Parameters**:

  * A tuple representing a spawn operation (e.g., `spawn(fn -> IO.inspect(:ok) end)`).
  * `context`: Current variable bindings.

* **Process**:

  * Extracts and parses the anonymous function to be spawned.
  * Constructs a `%Transpiler.Tree.Expression{}` with type `:spawn`.

* **Example**:

  * **Elixir**: `spawn(fn -> IO.inspect(:ok) end)`
  * **C**: `green_thread_create(lambda(void, (void* arg), { printf("works"); }), NULL);`

---

##### `parse/2` (Variable Reference)

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse({atom(), term(), nil}, map()) :: {%Transpiler.Tree.Expression{}, map()}
```

* **Parameters**:

  * A tuple representing a variable reference (e.g., `{varname, meta, nil}`).
  * `context`: Current variable bindings.

* **Process**:

  * Constructs a `%Transpiler.Tree.Expression{}` with type `:varname`.
  * Retrieves the variable's return type from the context.

* **Example**:

  * **Elixir**: `x`
  * **C**: `x`

---

##### `parse/2` (Literals)

* **Process**:

  * Constructs a `%Transpiler.Tree.Expression{}` with the appropriate `:type` and `:return_type`.

* **Examples**:

  * **Elixir**: `5` → **C**: `5`
  * **Elixir**: `3.14` → **C**: `3.14`
  * **Elixir**: `true` → **C**: `1`
  * **Elixir**: `"hello"` → **C**: `"hello"`

---

##### `generate_code/1`

Handles code generation for various expression types.

##### Print Expression

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.Expression{type: :print, arguments: []}) :: String.t()
```

* **Process**:

  * Generates a `printf` statement based on the argument's return type.

* **Example**:

  * **C**: `printf("%d \n", x);`

##### Spawn Expression

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.Expression{type: :spawn, arguments: []}) :: String.t()
```

* **Process**:

  * Generates a call to `green_thread_create()` with a lambda.

* **Example**:

  * **C**: `green_thread_create(lambda(void, (void* arg), { while (1) { printf("works"); } }), NULL);`

##### Assignment Expression

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.Expression{type: :assign, arguments: [any()]}) :: String.t()
```

* **Process**:

  * Determines the C type keyword based on the return type.
  * Generates the C assignment statement.

* **Example**:

  * **C**: `int x = 5;`

##### Literal Expressions

* **Examples**:  
  * **C**: `5`, `3.14`, `1`, `"hello"`

##### Binary Operations

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.Expression{}) :: String.t()
```

* **Process**:

  * Recursively generates code for operands.
  * Combines them with the appropriate C operator.

* **Example**:

  * **Elixir**: `x + y` → **C**: `x + y`

---

##### `infer_return_type/3`

**Signatures**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec infer_return_type(ast_elementary_ops(), temp_types(), temp_types()) :: temp_types()
@spec infer_return_type(ast_elementary_ops(), any(), any()) :: temp_types()
```

* **Process**:

  * Determines the return type based on the operation and operand types.
  * Arithmetic operations (`:+`, `:-`, `:*`, `:/`):  
    Returns `:float` if either operand is `:float`; otherwise, `:int`.
  * Comparison and logical operations (`:<`, `:>`, `:==`, `:!=`, `:&&`, `:||`):  
    Returns `:bool`.

* **Example**:

  * **Elixir**: `x + y` where `x: :int`, `y: :float` → **C**: `:float`

---

##### Integration in the Transpilation Pipeline

* **Input**:  
  Receives parsed Elixir expressions from the `Transpiler.Parser` module.

* **Processing**:  
  Converts Elixir expressions into `Transpiler.Tree.Expression` structs, inferring return types and handling different operation types.

* **Output**:  
  Generates the corresponding C code snippets for each expression, facilitating their inclusion in the final C output.

<!-- livebook:{"break_markdown":true} -->

#### 5. Main Block Parsing Module (Transpiler.Tree.MainBlock.ex)

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Transpiler.Tree.MainBlock do
  defstruct [:modules, :expressions]

  @type ast_elementary_ops() :: :+ | :- | :* | :/ | :< | :> | :== | :!= | :&& | :||
  @type ast_element() ::
          {
            ast_elementary_ops(),
            [
              line: integer()
            ],
            [ast_element()]
          }
          | nil

  @spec parse([ast_element()]) :: %Transpiler.Tree.MainBlock{}
  def parse(ast) do
    %__MODULE__{
      modules: [],
      expressions: parse_expressions(ast)
    }
  end

  @spec generate_code(%Transpiler.Tree.MainBlock{}) :: String.t()
  def generate_code(main_block) do
    """
    int main() {
        setup_fault_tolerance_signal_handler();
        /*
        code get inserted 👇
        */
        #{Enum.map_join(main_block.expressions, "    ;\n    ", &Transpiler.Tree.Expression.generate_code(&1))};
        /*
        code get inserted 👆
        */
        green_thread_run();
        return 0;
    }
    """
  end

  @spec parse_expressions([ast_element]) :: [%Transpiler.Tree.Expression{}]
  defp parse_expressions(ast) do
    {expressions, _} =
      Enum.map_reduce(ast, %{}, fn expression, context ->
        case Transpiler.Tree.Expression.parse(expression, context) do
          {expression, context} ->
            {expression, context}

          expression ->
            {expression, expression.context}
        end
      end)

    expressions
  end
end

```

<!-- livebook:{"break_markdown":true} -->

##### Task and Functionality

##### Purpose

Aggregates multiple parsed expressions into a structured `Transpiler.Tree.MainBlock` that represents the `main` function in C, encapsulating all program logic.

---

##### Data Structures

##### `%Transpiler.Tree.MainBlock{}` Struct

**Fields**:

* `:modules`: Reserved for future modular expansions (currently empty).
* `:expressions`: List of `%Transpiler.Tree.Expression{}` structs representing individual C statements.

---

##### Functions

##### `parse/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse([ast_element()]) :: %Transpiler.Tree.MainBlock{}
```

* **Parameters**:  
  `ast`: List of AST elements representing Elixir expressions.

* **Process**:

  * Initializes a `%Transpiler.Tree.MainBlock{}` struct with an empty `:modules` list.
  * Parses each AST expression using `parse_expressions/1` to populate the `:expressions` list.

* **Output**:  
  Returns a populated `%Transpiler.Tree.MainBlock{}` struct.

---

##### `generate_code/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.MainBlock{}) :: String.t()
```

* **Parameters**:  
  `main_block`: A `%Transpiler.Tree.MainBlock{}` struct containing all expressions.

* **Process**:

  * Constructs the C `main` function as a string.
  * Inserts setup and teardown code (e.g., `setup_fault_tolerance_signal_handler();` and `green_thread_run();`).
  * Iterates over the `:expressions` list, generating C code for each expression and inserting it into the `main` function.

* **Output**:  
  Returns the complete C `main` function as a string.

---

##### `parse_expressions/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse_expressions([ast_element()]) :: [%Transpiler.Tree.Expression{}]
```

* **Parameters**:  
  `ast`: List of AST elements representing Elixir expressions.

* **Process**:

  * Iterates over each expression in the AST.
  * Parses each expression using `Transpiler.Tree.Expression.parse/2`.
  * Accumulates the parsed `%Transpiler.Tree.Expression{}` structs into a list.

* **Output**:  
  Returns a list of parsed `%Transpiler.Tree.Expression{}` structs.

---

##### Integration in the Transpilation Pipeline

* **Input**:  
  Receives a list of parsed Elixir expressions from the `Transpiler.Parser` module.

* **Processing**:

  * Aggregates these expressions into a `MainBlock`, which structures the C `main` function.
  * Includes all necessary setup, execution, and teardown code.

* **Output**:  
  Generates the complete C `main` function, ready for inclusion in the final C code output by the `Transpiler.CodeGenerator` module.

<!-- livebook:{"break_markdown":true} -->

#### 6. Code Generation Module (Transpiler.CodeGenerator.ex)

<!-- livebook:{"break_markdown":true} -->

<!-- livebook:{"force_markdown":true} -->

```elixir
defmodule Transpiler.CodeGenerator do

  @type generated_c_code() :: binary()

  @spec generate_code(%Transpiler.Tree.MainBlock{}) :: generated_c_code()
  def generate_code(main_block) do
    """
    #include <stdio.h>
    #include "obz_scheduler.h"

    #{Transpiler.Tree.MainBlock.generate_code(main_block)}
    """
  end
end
```

<!-- livebook:{"break_markdown":true} -->

##### Task and Functionality

##### Purpose

Finalizes the C code generation process by assembling the complete C source file, including necessary headers and the main function generated by the `Transpiler.Tree.MainBlock` module.

---

##### Functions

##### `generate_code/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.MainBlock{}) :: generated_c_code()
```

* **Parameters**:  
  `main_block`: A `%Transpiler.Tree.MainBlock{}` struct containing all parsed expressions.

* **Process**:

  1. Concatenates the necessary C header includes (`<stdio.h>` and `"obz_scheduler.h"`).
  2. Calls `Transpiler.Tree.MainBlock.generate_code/1` to generate the main function code.
  3. Assembles the headers and main function into a complete C source code string.

* **Output**:  
  Returns the complete C source code as a binary string.

---

##### Integration in the Transpilation Pipeline

* **Input**:  
  Receives a `%Transpiler.Tree.MainBlock{}` struct containing the `main` function's expressions.

* **Processing**:  
  Combines the necessary C headers with the generated `main` function code to produce the final C source code.

* **Output**:  
  Returns the complete C source code, ready to be written to an output file by the CLI module.

<!-- livebook:{"break_markdown":true} -->

##### Comprehensive Overview of the Transpiler System

##### 7. Expression Parsing Details (`Transpiler.Tree.Expression`)

The `Transpiler.Tree.Expression` module is pivotal in converting Elixir expressions into their C equivalents. It meticulously handles various types of expressions, including arithmetic operations, assignments, print statements, and thread spawning.

---

##### Data Structures and Type Definitions

##### Struct

* **`%Transpiler.Tree.Expression{}`**:  
  Represents a single parsed expression with its operands, operation type, inferred return type, and contextual information.

##### Type Definitions

* **`ast_elementary_ops()`**:  
  Defines elementary arithmetic and logical operators.

* **`ast_elementary_ops_with_assignment()`**:  
  Extends `ast_elementary_ops()` to include the assignment (`:=`) operator.

* **`ast_elementary_funs()`**:  
  Enumerates functions related to thread spawning (`:spawn`, `:fn`).

* **`literal_type()`**:  
  Enumerates types for literals (`:integer_literal`, `:float_literal`, `:boolean_literal`, `:string_literal`).

---

##### Parsing Functions

##### Arithmetic and Logical Operations

* Handles binary operations (e.g., `:+`, `:-`, `:*`, `:/`, `:&&`, `:||`).
* Recursively parses left and right operands.
* Infers return types based on operands and operation.

##### Assignment Operations

* Parses variable assignments (`:=`).
* Updates the context with new variable bindings.
* Determines the C type keyword based on the return type of the right-hand side expression.

##### Print Operations

* Maps `IO.inspect` calls to C's `printf` statements.
* Infers the appropriate `printf` format string based on the argument's type.

##### Thread Spawning

* Parses `spawn` calls, extracting and parsing the anonymous function for execution in a new green thread.
* Constructs a spawn expression using `green_thread_create`.

##### Variable References and Literals

* Ensures correct type inference for variable references.
* Parses literals (integers, floats, booleans, strings) into their C equivalents.

---

##### Code Generation Functions

##### `generate_code/1`

* Generates C code for each parsed expression.
* Handles specific cases for `:print`, `:spawn`, `:assign`, binary operations, and literals.

##### `infer_return_type/3`

* Infers the return type based on operation and operand types.
* Ensures type correctness in generated C code.

---

##### Helper Functions

##### `parse_anonymous_fun_content/1`

* Converts parsed expressions within an anonymous function into a C-compatible loop structure.
* Wraps the function's content in a `while (1) { ... }` loop to emulate Elixir's persistent process behavior.

---

##### Example Workflow

**Elixir Code**:

<!-- livebook:{"force_markdown":true} -->

```elixir
x = 5
y = "hello"
IO.inspect(x)
spawn(fn -> IO.inspect(:ok) end)
```

**Transpiled C Code**:

```c
#include <stdio.h>
#include "obz_scheduler.h"

int main() {
    setup_fault_tolerance_signal_handler();
    int x = 5;
    char* y = "hello";
    printf("%d \n", x);
    green_thread_create(
        lambda(void, (void* arg), { 
            while (1) { printf("works"); } 
        }), NULL);
    green_thread_run();
    return 0;
}
```

---

##### 8. Main Block Parsing Details (`Transpiler.Tree.MainBlock`)

The `Transpiler.Tree.MainBlock` module orchestrates the assembly of individual C statements into a cohesive `main` function.

---

##### Data Structures and Type Definitions

##### Struct

* **`%Transpiler.Tree.MainBlock{}`**:  
  Represents the `main` function's structure, containing:  
  * `:modules` (reserved for future use).
  * `:expressions` (list of parsed C statements).

##### Type Definitions

* **`ast_elementary_ops()`**:  
  Defines elementary arithmetic and logical operators.

* **`ast_element()`**:  
  Represents an AST element, which can be a binary operation or `nil`.

---

##### Parsing Functions

##### `parse/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse([ast_element()]) :: %Transpiler.Tree.MainBlock{}
```

* **Process**:  
  * Constructs a `%Transpiler.Tree.MainBlock{}` struct.
  * Calls `parse_expressions/1` to populate the `:expressions` list.

#### `parse_expressions/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec parse_expressions([ast_element()]) :: [%Transpiler.Tree.Expression{}]
```

* **Process**:  
  * Iterates over AST elements.
  * Parses each using `Transpiler.Tree.Expression.parse/2`.
  * Accumulates parsed expressions into a list.

---

##### Code Generation Functions

##### `generate_code/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.MainBlock{}) :: String.t()
```

* **Process**:  
  * Constructs the C `main` function.
  * Inserts setup (`setup_fault_tolerance_signal_handler();`).
  * Iterates over `:expressions`, generating code for each.
  * Adds teardown (`green_thread_run();`).

---

##### Example Workflow

**Parsed Expressions**:

<!-- livebook:{"force_markdown":true} -->

```elixir
%Transpiler.Tree.Expression{
    type: :assign,
    arguments: [
        "x",
        %Transpiler.Tree.Expression{
            type: :integer_literal,
            arguments: [5],
            return_type: :int
        }
    ]
}
```

**Generated C Code**:

```c
int main() {
    setup_fault_tolerance_signal_handler();
    int x = 5;
    green_thread_run();
    return 0;
}
```

---

##### 9. Final Code Generation Module (`Transpiler.CodeGenerator`)

The `Transpiler.CodeGenerator` module finalizes C code generation by incorporating necessary headers and the `main` function.

---

##### Purpose

Combines C headers with the generated `main` function to produce the complete C source code.

---

##### Functions

##### `generate_code/1`

**Signature**

<!-- livebook:{"force_markdown":true} -->

```elixir
@spec generate_code(%Transpiler.Tree.MainBlock{}) :: String.t()
```

* **Process**:  
  * Adds standard headers (`<stdio.h>` and `"obz_scheduler.h"`).
  * Appends the `main` function code from `Transpiler.Tree.MainBlock`.

---

##### Example Output

**Complete C Code**:

```c
#include <stdio.h>
#include "obz_scheduler.h"

int main() {
    setup_fault_tolerance_signal_handler();
    int x = 5;
    green_thread_run();
    return 0;
}
```

---

##### Comprehensive Workflow Summary

1. **Elixir Code Input**:  
   User provides Elixir code via file or CLI input.

2. **Transpilation Initiation**:

   * Elixir code is parsed into an AST.
   * The AST is passed to `Transpiler.Parser`.

3. **Expression Parsing**:

   * `Transpiler.Tree.Expression` parses and structures expressions.
   * Types are inferred, and C code fragments are generated.

4. **Main Block Parsing**:

   * `Transpiler.Tree.MainBlock` aggregates expressions into the `main` function.

5. **C Code Generation**:

   * `Transpiler.CodeGenerator` adds headers and assembles the full C source.

6. **Output Delivery**:

   * The final C code is written to `main.c`.

---

##### Final Output

**Executable C Code**:  
The transpiler produces a fully functional `main.c` file, ready for compilation and execution.

<!-- livebook:{"break_markdown":true} -->

#### 4.2- C Code Compilation

<!-- livebook:{"break_markdown":true} -->

<!-- Learn more at https://mermaid-js.github.io/mermaid -->

```mermaid
graph TD
        A[Transpiled Elixir Code]
        AA[int x = 0;]
        AB[char* y = &quot;this is a string&quot;]
        AC[lambda#40;#40;void#41;, #40;void *arg#41;,  printf#40;&quot;works&quot;#41;; #41;]
        AD[Expanded anonymous function declaration]
        AE[green_thread_create#40;#41;]
        GT[green_thread]
        FN[Anonymous Function]

    subgraph Scheduler
        S1[Scheduler]
    end

    A -->|contains 0..*| AA
    A -->|contains 0..*| AB
    A -->|contains 0..*| AC -->|macro expansion| AD
    AD -->|wrapped in green thread| AE
    AE -->|Spawn 1..* green threads| GT -->|execute| FN

    S1 -->|manage execution| GT


  

```

<!-- livebook:{"break_markdown":true} -->

#### Component Breakdown

* **1. Transpiled Elixir Code**

  * **Description:**
    * Represents the C code generated from the original Elixir source code by the transpiler.
  * **Components:**
    * **int x = 0; :** A simple integer variable declaration and initialization.
    * **char* y = "this is a string";:** A string declaration using a character pointer.
    * **lambda((void), (void *arg), printf("works"); ) :** An anonymous function represented as a lambda in C, which prints "works" when executed.

* **2. Macro Expansion and Function Wrapping**

  * **Anonymous Function Expansion :**
    * **lambda((void), (void *arg), printf("works"); ) :**
  * **Purpose:** Defines an anonymous function using a lambda expression in C.
  * **Macro Expansion :**
    * **Expanded anonymous function declaration :**
      * **Functionality:** The lambda is expanded using C macros (leveraging GCC statement blocks) to convert the anonymous function into a format compatible with the green thread system.
      * **Example Expansion:** The macro might transform the lambda into a standard C function or a specific structure that the green thread library can handle.
  * **Wrapping into Green Threads :**
    * **green_thread_create() :**
      * **Functionality:** A macro or function that wraps the expanded anonymous function into a green thread.
      * **Purpose:** Prepares the anonymous function for concurrent execution by encapsulating it within the green thread infrastructure.
  * **Spawning Green Threads :**
    * **green_thread :**
      * **Description:** Represents an individual green thread instance created by green_thread_create().
      * **Functionality:** Manages the execution of the wrapped anonymous function (FN).
  * **Executing Anonymous Functions :**
    * **Anonymous Function :**
      * **Description:** The actual function logic that gets executed within the green thread.
      * **Functionality:** In this case, it executes printf("works");, demonstrating the functionality of the anonymous function within the concurrent environment.

* **3. Scheduler Management**

  * **Scheduler :**
    * **Role:** Central component responsible for managing the execution of all active green threads.
    * **Functionality:**
      * **Scheduling:** Implements the preemptive round-robin scheduling policy to allocate CPU time slices to each green thread.
      * **Execution Management:** Ensures that green threads are executed in an orderly and efficient manner, handling context switches and maintaining thread states.
  * **Interaction with Green Threads :**
    * **Manage Execution:** The scheduler oversees the lifecycle of each green thread, ensuring that the anonymous functions  execute correctly and efficiently.
    * **Concurrency Control:** Balances the execution of multiple green threads, preventing any single thread from monopolizing system resources.

<!-- livebook:{"break_markdown":true} -->

#### Detailed Execution Flow

* **Transpilation:**

  * Elixir source code is transpiled into C code, including variable declarations and anonymous functions transformed into C-compatible constructs.

* **Compilation and Linking:**

  * The transpiled C code is compiled and linked with the runtime library, which includes the green thread management and scheduler components.

* **Runtime Initialization:**

  * Upon execution, the runtime initializes the scheduler and prepares the Global Threads Array for managing green threads.

* **Green Thread Creation:**

  * The transpiled C code invokes green_thread_create() for each anonymous function, wrapping them into green threads and adding them to the threads array.

* **Scheduling and Execution:**

  * The Scheduler begins managing the execution of green threads, allocating CPU time slices in a round-robin fashion.
  * Each green thread executes its assigned anonymous function (FN), performing tasks such as printing messages or other computational work.

* **Concurrency Management:**

  * Multiple green threads run concurrently within the same process, enabling high levels of parallelism without the overhead of OS-level threads.

* **Fault Tolerance Handling:**

  * If a green thread encounters an error or crashes, the isolated heap ensures that other threads continue to execute unaffected.
  * The scheduler monitors thread health, potentially restarting failed threads based on future enhancements like supervisor trees.

* **Completion and Cleanup:**

  * As green threads complete their execution, they are removed from the Global Threads Array, and resources are freed.
  * The runtime gracefully shuts down once all green threads have finished executing.

<!-- livebook:{"break_markdown":true} -->

#### Integration with Overall Project Architecture

**The Runtime Phase seamlessly integrates with other components of your project, ensuring that transpiled C code operates within a robust, concurrent, and fault-tolerant environment.**

* **Transpiler (Transpiler.CodeGenerator → Transpiled C Code):**

  * Converts Elixir code into C, including variable declarations and anonymous function definitions.
    The generated C code is designed to interact with the runtime's green thread system.

* **Type Mappings:**

  * Ensures that Elixir types are accurately translated into C types, maintaining type safety and functional equivalence.
  * Facilitates the correct handling of complex constructs like anonymous functions.

* **Runtime Architecture:**

  * **Greenthread Management Module:**
    * Handles the creation and management of green threads, integrating with the scheduler.
  * **Global Threads Array:**
    * Central repository for all active green threads, enabling efficient scheduling and execution management.
  * **Scheduler:**
    * Manages the execution flow, ensuring fair CPU time distribution and handling context switches.

* **Concurrency and Fault Tolerance:**

  * **Concurrency Model:**
    * Leverages preemptive round-robin scheduling and isolated heaps to handle multiple concurrent tasks efficiently.
  * **Fault Tolerance:**
    * Implements the "Let it Crash" philosophy, ensuring that individual thread failures do not impact the entire system.

* **Performance Considerations:**

  * **Thread Pool Management:**
    * Mitigates overheads associated with creating and managing multiple green threads, optimizing resource utilization.
  * **Optimized Scheduling:**
    * Ensures minimal latency and efficient context switching, enhancing overall system performance.

<!-- livebook:{"break_markdown":true} -->

#### Benefits of the Runtime Phase Design

* **High Concurrency:**

  * **Green Threads:** Enable efficient concurrent execution within a single OS thread, reducing overhead and improving performance.
  * **Scalability:** Capable of handling thousands of concurrent tasks due to the lightweight nature of green threads.

* **Fault Isolation:**

  * **Isolated Heaps:** Prevent faults in one green thread from affecting others, enhancing system reliability.
  * **"Let it Crash"** Philosophy: Ensures that the system remains operational even when individual threads fail.

* **Performance Optimization:**

  * **Preemptive Scheduling:** Balances CPU time among green threads, ensuring fair resource distribution.
  * **Thread Pool Management:** Reduces overhead by reusing green threads and minimizing the cost of thread creation and destruction.

* **Modularity and Extensibility:**

  * **Modular Design:** Facilitates maintenance and future enhancements, such as implementing supervisor trees and dynamic supervision strategies.
  * **Macro-Based Function Wrapping:** Provides flexibility in handling anonymous functions, allowing for easy adaptation and extension.

* **Seamless Integration:**

  * **Transpiler Compatibility:** The runtime is designed to work seamlessly with the transpiled C code, ensuring smooth execution of translated Elixir programs.
  * **Type Safety and Correctness:** Maintains the integrity of the original Elixir code through accurate type mappings and functional equivalence.

<!-- livebook:{"break_markdown":true} -->

#### Detailed Code Explanation and Task Overview

<!-- livebook:{"break_markdown":true} -->

#### Headers

<!-- livebook:{"break_markdown":true} -->

##### 1. Anonymous.h

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: anonymous.h
 * @author: Obz Team
 * This file concerns
 */

#ifndef ANONYMOUS_H_
#define ANONYMOUS_H_
#include "obz_scheduler.h"

/**
 * This macro takes the return, the args (variable) and the body (as a block) and
 * plugs it out and return the address of the function pointer to be consumed by
 * the green_thread_create() function (takes it as a wrapper).
 */
#define lambda(lambda$_ret, lambda$_args, lambda$_body)\
  ({\
    lambda$_ret lambda$__anon$ lambda$_args\
      lambda$_body\
    &lambda$__anon$;\
  })

#endif // ANONYMOUS_H_

```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality of the Lambda Macro

##### Lambda Macro

##### Definition

The `lambda` macro facilitates the creation of anonymous functions in C, mimicking Elixir's `fn` constructs.

---

##### Parameters

* **`lambda$_ret`**: The return type of the function.
* **`lambda$_args`**: The arguments the function accepts.
* **`lambda$_body`**: The body of the function as a block of code.

---

##### Functionality

##### 1. **Function Declaration**

Defines an anonymous function named `lambda$__anon$` with:

* The specified return type (`lambda$_ret`).
* The specified arguments (`lambda$_args`).

##### 2. **Function Body**

Inserts the provided body (`lambda$_body`) into the function definition.

##### 3. **Function Pointer**

Returns the address of the anonymous function, enabling it to be:

* Stored as a function pointer.
* Passed to `green_thread_create()` for execution in a green thread.

---

##### Integration

##### Usage in Transpiled Code

* **Transpiler Role**:  
  When the transpiler processes an anonymous function in Elixir, it generates a corresponding C lambda expression using the `lambda` macro.

* **Green Thread Creation**:  
  The lambda expression is passed to `green_thread_create()` to spawn a new green thread for concurrent execution.

---

##### Example

**Elixir Code**:

<!-- livebook:{"force_markdown":true} -->

```elixir
spawn(fn -> IO.inspect(:ok) end)
```

**Generated C Code**:

```c
green_thread_create(
    lambda(void, (void* arg), { 
        while (1) { printf("works"); } 
    }), NULL
);
```

**Explanation**:

1. The `lambda` macro creates an anonymous function in C:
   * **Return Type**: `void`
   * **Arguments**: `(void* arg)`
   * **Body**: `{ while (1) { printf("works"); } }`
2. This function is passed as a pointer to `green_thread_create()`, which spawns a green thread to execute the anonymous function.

---

<!-- livebook:{"break_markdown":true} -->

##### 2. thread.h

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: thread.h
 * @author: Obz Team
 * This file contains foundational data structures and Enums. GreenThread is a struct comprising metadata about the green threads,
 * the ThreadState enum contains possible states of a green thread.
 */

#ifndef THREAD_H_
#define THREAD_H_
#include <ucontext.h>

/**
 * This Enum is used to differentiate between the possible green threads states.
 */
typedef enum {
    READY,
    RUNNING,
    FINISHED
} ThreadState;

/**
 * GreenThread is a struct that holds metadata about a green thread:
 * - context: Contains the execution context (registers, stack pointer, etc.).
 * - stack: Points to the custom stack allocated for the thread.
 * - id: Unique identifier for the thread.
 * - state: Current state of the thread (READY, RUNNING, FINISHED).
 * - function: Pointer to the function the thread will execute.
 * - arg: Argument to be passed to the function.
 */
typedef struct GreenThread {
    ucontext_t context;
    void* stack;
    int id;
    ThreadState state;
    void (*function)(void*);
    void* arg;
} GreenThread;

#endif // THREAD_H_

```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality

##### ThreadState Enum

##### Values

* **`READY`**: The thread is ready to run.
* **`RUNNING`**: The thread is currently executing.
* **`FINISHED`**: The thread has completed execution.

##### Functionality

Tracks the current state of each green thread, enabling the Scheduler to make informed scheduling decisions.

---

##### GreenThread Struct

##### Fields

1. **`context`**:

   * Stores the thread's execution context, including CPU registers and stack pointers.
   * Utilizes `ucontext_t` from `<ucontext.h>`.

2. **`stack`**:

   * Points to the thread's custom stack allocated in memory.

3. **`id`**:

   * Unique identifier assigned to each thread.

4. **`state`**:

   * Current state of the thread (`READY`, `RUNNING`, `FINISHED`).

5. **`function`**:

   * Pointer to the function that the thread will execute.

6. **`arg`**:

   * Argument to be passed to the thread's function during execution.

---

##### Integration

##### Thread Creation

* When `green_thread_create()` is invoked:  
  1. A new `GreenThread` struct is instantiated.
  2. The following fields are initialized:  
     * `context` (execution context).
     * `stack` (memory allocation for the thread's stack).
     * `function` (pointer to the thread's function).
     * `arg` (argument for the thread's function).

##### Scheduling

* The **Scheduler**:  
  1. Manages a collection of `GreenThread` instances.
  2. Updates their states (`READY`, `RUNNING`, `FINISHED`) based on their progress.
  3. Handles context switches to ensure efficient execution of green threads.

---

##### Example Workflow

##### Thread Creation

**Invocation**:

```c
green_thread_create(my_function, &my_arg);
```

**Result**:

* A new `GreenThread` struct is created:  
  * `function` → `my_function`
  * `arg` → `&my_arg`
  * `state` → `READY`

---

##### Scheduling and Execution

1. **Scheduler** selects a `GreenThread` with state `READY`.
2. The thread's `state` is updated to `RUNNING`.
3. `function` is executed with `arg`.
4. Upon completion, the thread's `state` is updated to `FINISHED`.

---

<!-- livebook:{"break_markdown":true} -->

##### 3. scheduler.h

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: scheduler.h
 * @author: Obz Team
 * This file contains the foundational data structure Scheduler, which comprises all the data about the global scheduler object.
 */

#ifndef SCHEDULER_H_
#define SCHEDULER_H_

#include "thread.h"
#include "obz_scheduler.h"

/**
 * Scheduler is a struct that holds metadata about the global scheduler object, responsible for scheduling green threads:
 * - threads: An array holding pointers to GreenThread objects.
 * - thread_count: Number of active green threads.
 * - current_thread: Index of the currently running thread.
 * - main_context: The main execution context.
 * - old_timer: Stores the previous timer settings to restore after scheduling.
 * - old_action & is_switching: Reserved for future use.
 */
typedef struct Scheduler {
    GreenThread* threads[MAX_THREADS];
    int thread_count;
    int current_thread;
    ucontext_t main_context;
    struct sigaction old_action; // Placeholder for context switching
    struct itimerval old_timer;
    bool is_switching;
} Scheduler;

#endif // SCHEDULER_H_

```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality

##### Scheduler Struct

##### Fields

1. **`threads[MAX_THREADS]`**:

   * Array of pointers to `GreenThread` instances.
   * Represents all active green threads managed by the scheduler.

2. **`thread_count`**:

   * Tracks the number of active green threads in the scheduler.

3. **`current_thread`**:

   * Index of the currently executing thread within the `threads` array.

4. **`main_context`**:

   * Stores the execution context of the main thread.
   * Allows the scheduler to return control to the main thread after scheduling.

5. **`old_action`**:

   * Placeholder for storing previous signal actions.
   * Aids in context switching between threads.

6. **`old_timer`**:

   * Stores previous timer configurations.
   * Ensures timer settings can be restored after scheduling is complete.

7. **`is_switching`**:

   * Boolean flag indicating whether a context switch is currently in progress.
   * Reserved for future enhancements to improve runtime behavior.

---

##### Integration

##### Global Scheduler Object

* The **`Scheduler`** struct is instantiated globally (as defined in `scheduler.c`).
* Serves as the central entity for managing green threads.
* Provides runtime components with collective access to all thread management functionality.

---

##### Thread Management

* **Thread Addition**:  
  Functions in the runtime use the Scheduler to add new threads to the `threads` array and increment `thread_count`.

* **State Management**:  
  The Scheduler tracks and updates the states of green threads (`READY`, `RUNNING`, `FINISHED`) during execution.

* **Context Switching**:

  * Facilitates transitions between threads by saving and restoring execution contexts using `ucontext_t`.
  * Leverages `main_context` to return control to the main thread when necessary.

---

##### Example Workflow

1. **Thread Creation**:

   * A new thread is added to the Scheduler using `green_thread_create()`.
   * The `threads` array is updated with the new `GreenThread` instance.
   * `thread_count` is incremented.

2. **Scheduling**:

   * The Scheduler selects the next thread with state `READY`.
   * Updates `current_thread` to the selected thread's index.
   * Performs a context switch to execute the thread.

3. **Execution**:

   * The selected thread's state is updated to `RUNNING`.
   * Upon completion, the thread's state is set to `FINISHED`.

4. **Control Return**:

   * Once all threads are complete, the Scheduler uses `main_context` to return control to the main thread.

---

<!-- livebook:{"break_markdown":true} -->

##### 4. obz_scheduler.h

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: obz_scheduler.h
 * @author: Obz Team
 * This file contains the signatures for the dynamically linked functions that are used when compiling
 * the sample program with our statically linked library.
 * Each function is well documented in its appropriate file.
 */

#ifndef OBZ_SCHEDULER_H_
#define OBZ_SCHEDULER_H_

#include <stdio.h>
#include <stdlib.h>
#include <ucontext.h>
#include <signal.h>
#include <string.h>
#include <stdbool.h>
#include <sys/time.h>
#include <unistd.h>
#include <fcntl.h>

static void schedule_next_thread(void);
void thread_wrapper(void);
static void setup_timer(void);
static void timer_handler(int signum);
int green_thread_create(void (*function)(void*), void* arg);
void green_thread_run(void);
void setup_fault_tolerance_signal_handler();
void run();

#define STACK_SIZE (1024 * 1024)  // 1MB stack size (arbitrary)
#define MAX_THREADS 64
#define TIME_SLICE_MS 256 // Sets the context switching interval (a hack)

#endif // OBZ_SCHEDULER_H_

```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality

##### Function Prototypes

##### 1. **`schedule_next_thread`**

* **Purpose**:  
  Handles the logic for selecting and switching to the next green thread for execution.
* **Functionality**:  
  * Iterates through the thread array to find the next thread in the `READY` state.
  * Performs context switching to the selected thread.

---

##### 2. **`thread_wrapper`**

* **Purpose**:  
  Acts as a wrapper for thread execution.
* **Functionality**:  
  * Sets the thread's state to `RUNNING`.
  * Executes the thread's function with its argument.
  * Marks the thread's state as `FINISHED` upon completion.

---

##### 3. **`setup_timer`**

* **Purpose**:  
  Configures a timer (`ITIMER_REAL`) to send periodic `SIGALRM` signals.
* **Functionality**:  
  * Defines the timer's interval, based on `TIME_SLICE_MS`.
  * Enables preemptive scheduling by triggering context switches.

---

##### 4. **`timer_handler`**

* **Purpose**:  
  Signal handler for `SIGALRM`.
* **Functionality**:  
  * Invokes `schedule_next_thread` to handle context switching.
  * Ensures timely transitions between green threads based on the timer.

---

##### 5. **`green_thread_create`**

* **Purpose**:  
  Creates and initializes a new green thread.
* **Functionality**:  
  * Allocates a stack for the thread (`STACK_SIZE`).
  * Initializes the thread's `ucontext_t` context.
  * Adds the new thread to the scheduler's thread array.

---

##### 6. **`green_thread_run`**

* **Purpose**:  
  Manages the execution lifecycle of green threads.
* **Functionality**:  
  * Initiates the scheduler and starts the timer.
  * Continuously schedules and executes threads until all are completed.

---

##### 7. **`setup_fault_tolerance_signal_handler`**

* **Purpose**:  
  Sets up signal handlers for fault tolerance.
* **Functionality**:  
  * Manages critical signals like `SIGINT`, `SIGSEGV`, and `SIGFPE`.
  * Ensures safe and predictable runtime behavior during faults.

---

##### 8. **`run`**

* **Purpose**:  
  Placeholder for potential future enhancements.
* **Functionality**:  
  Provides extensibility for additional runtime functionalities.

---

##### Macros and Definitions

##### **`STACK_SIZE`**

* **Purpose**:  
  Defines the stack size for each green thread.
* **Value**: `1MB` (`1 * 1024 * 1024`).

##### **`MAX_THREADS`**

* **Purpose**:  
  Sets the maximum number of green threads the scheduler can manage.
* **Value**: `64`.

##### **`TIME_SLICE_MS`**

* **Purpose**:  
  Specifies the duration of each time slice in milliseconds, determining how frequently context switches occur.
* **Value**: `256ms`.

---

##### Integration

##### **Runtime Execution Flow**

These functions collectively manage the lifecycle of green threads, including:

1. **Thread Creation**:  
   Using `green_thread_create()` to initialize threads.
2. **Scheduling**:  
   Configuring timers and handling context switches with `setup_timer` and `schedule_next_thread`.
3. **Execution**:  
   Running threads via `green_thread_run()` and marking completion with `thread_wrapper`.

---

##### **Interfacing with Transpiled Code**

* **Role in Transpiled Code**:  
  The `green_thread_create()` function is invoked by the transpiled C code (derived from Elixir).
* **Functionality**:  
  * Allows user-defined anonymous functions to execute in green threads.
  * Leverages the runtime's scheduling and context-switching mechanisms for concurrency.

---

<!-- livebook:{"break_markdown":true} -->

#### C-Source Files

<!-- livebook:{"break_markdown":true} -->

##### 1. fallback.c

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: fallback.c
 * @author: Obz team
 *
 * This file contains functions concerning handling interrupts and other signals besides the `SIGALRM`
 * that's used in the scheduling of the green threads.
 */

#include "obz_scheduler.h"
#include "scheduler.h"

// Scheduler is a global object defined in scheduler.c
extern Scheduler scheduler;

/**
 * Fallback signal handler for handling unexpected signals like SIGINT and SIGFPE.
 * Implements rudimentary fault tolerance by logging errors and terminating the program gracefully.
 */
void fallback(int signum) {
    // TODO: Add a crash log mechanism to record all process crashes

    if (signum == SIGINT){
        printf("[Error] This is an interrupt C^c\n");
        exit(SIGINT);
    }

    if (signum == SIGFPE){
        printf("[Error] Floating point exception raised\n");
    }
    sleep(4000);
}

/**
 * Sets up the signal handlers for fault tolerance, specifically for SIGFPE, SIGSEGV, and SIGINT.
 * Ensures that the program can handle unexpected crashes without compromising the entire system.
 */
void setup_fault_tolerance_signal_handler() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = &fallback;
    sigaction(SIGFPE, &sa, &scheduler.old_action);
    sigaction(SIGSEGV, &sa, &scheduler.old_action);
    sigaction(SIGINT, &sa, &scheduler.old_action);
}
```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality

##### `fallback` Function

##### Role

Acts as a basic signal handler to manage unexpected signals, such as `SIGINT` (interrupt) and `SIGFPE` (floating-point exception).

---

##### Behavior

##### **`SIGINT`**

* Logs an interrupt message.
* Terminates the program gracefully using `exit(SIGINT)`.

##### **`SIGFPE`**

* Logs a floating-point exception message.
* Does **not** terminate the program immediately.
* Includes a `sleep(4000);` to allow ongoing threads to complete or stabilize.

##### **Other Signals**

* Logs the receipt of other signals.
* Causes the program to sleep for an extended period, potentially serving as a placeholder for more robust error-handling logic.

---

##### `setup_fault_tolerance_signal_handler` Function

##### Role

Initializes signal handlers for fault tolerance by setting up the `fallback` function to handle specific signals.

---

##### Behavior

##### **Signal Actions**

* Assigns `fallback` as the handler for the following signals:
  * `SIGFPE` (floating-point exception).
  * `SIGSEGV` (segmentation fault).
  * `SIGINT` (interrupt signal).

##### **Preservation of Previous Actions**

* Stores the previous signal actions in `scheduler.old_action`.
* Allows restoration or chaining of signal handlers if necessary.

---

##### Integration

##### **Fault Tolerance Mechanism**

* **Purpose**:  
  Provides resilience against unexpected errors during the execution of green threads.
* **Functionality**:  
  * Ensures that critical signals do not cause undefined behavior or a complete program crash.
  * Logs errors for debugging and either terminates gracefully (`SIGINT`) or allows stabilization (`SIGFPE`).

---

##### **Initialization**

* **When Called**:  
  `setup_fault_tolerance_signal_handler()` is invoked at the start of the `main` function in the generated C code.
* **Why**:  
  Establishes robust signal handlers **before** any green threads begin execution, ensuring runtime stability from the outset.

---

##### Example Workflow

##### During Runtime

1. **Signal Encountered**:  
   * A signal such as `SIGINT` or `SIGFPE` is raised during execution.
2. **Fallback Invoked**:  
   * The `fallback` function logs the error and performs the appropriate action (e.g., exiting or stabilizing).
3. **Thread Safety**:  
   * Ongoing threads are allowed to complete when possible, ensuring graceful degradation rather than abrupt termination.

---

<!-- livebook:{"break_markdown":true} -->

##### 2. fault_tolerance.c

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: fault_tolerance.c
 * @author: Obz team
 *
 * This file contains functions concerning handling interrupts and other signals besides the `SIGALRM`
 * that's used in the scheduling of the green threads.
 */

#include "obz_scheduler.h"
#include <signal.h>

extern struct sigaction sa;
void signal_handler(int sig);

/**
 * Sets up additional signal handlers for fault tolerance, handling signals like SIGSEGV, SIGFPE, and SIGILL.
 * Currently, the `signal_handler` function is empty and serves as a placeholder for future enhancements.
 */
void setup_handle_signals() {
    sigaction(SIGSEGV, &sa, NULL);
    sigaction(SIGFPE, &sa, NULL);
    sigaction(SIGILL, &sa, NULL);
}

/**
 * Placeholder signal handler function.
 * Intended to be expanded with more robust error handling and recovery mechanisms.
 */
void signal_handler(int sig){
    // TODO: Implement comprehensive signal handling logic
}
``
```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality

##### `setup_handle_signals` Function

##### Role

Configures signal handlers for additional fault tolerance by associating the `signal_handler` function with specific signals.

---

##### Behavior

##### **Signal Actions**

* Assigns the `signal_handler` function as the handler for the following signals:  
  * `SIGSEGV` (segmentation fault).
  * `SIGFPE` (floating-point exception).
  * `SIGILL` (illegal instruction).

##### **Preservation of Previous Actions**

* Does **not** store previous signal actions.
* This design choice implies:  
  * Either this function duplicates functionality from `setup_fault_tolerance_signal_handler`.
  * Or it is intended for future differentiation.

---

##### `signal_handler` Function

##### Role

Serves as a placeholder for handling critical signals.

---

##### Behavior

##### **Current State**

* **Empty Function Body**:  
  * When a signal is received, `signal_handler` performs no actions.

##### **Future Enhancements**

* Intended for expansion with:  
  * Mechanisms to log errors.
  * Recovery strategies to restore runtime stability.
  * Graceful shutdown processes to clean up resources.

---

##### Integration

##### **Fault Tolerance Extension**

* **Current Status**:

  * `fallback.c` provides basic signal handling.
  * `fault_tolerance.c` appears to extend this mechanism but currently duplicates functionality without adding value.

* **Future Development**:

  * Consolidation or differentiation between `fallback.c` and `fault_tolerance.c` is necessary to avoid redundancy.
  * `signal_handler` should be expanded with comprehensive error-handling logic.

---

##### **Initialization**

* **During Runtime**:  
  * Either `setup_fault_tolerance_signal_handler` (from `fallback.c`) or `setup_handle_signals` (from `fault_tolerance.c`) should be invoked during initialization.
  * This ensures the appropriate signal handlers are in place.

---

##### Key

##### `setup_handle_signals`

* Configures `signal_handler` as the handler for critical signals (`SIGSEGV`, `SIGFPE`, `SIGILL`).
* Lacks functionality to preserve previous signal actions, leading to potential redundancy with `setup_fault_tolerance_signal_handler`.

##### `signal_handler`

* Currently a placeholder with no implementation.
* Intended to be expanded for logging, recovery, and graceful shutdowns.

##### Future Considerations

* The current state of `fault_tolerance.c` and `fallback.c` indicates duplication rather than enhancement.
* Future efforts should focus on:
  * Consolidating signal-handling logic.
  * Expanding `signal_handler` to implement advanced fault tolerance mechanisms.
  * Ensuring the runtime has robust and unified error-handling capabilities.

<!-- livebook:{"break_markdown":true} -->

##### 3. scheduler.c

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: scheduler.c
 * @author: Obz team
 *
 * This file contains functions concerning the initialization of the global scheduler object and functions concerning the internals
 * of the scheduler (runtime).
 */

#include "obz_scheduler.h"
#include "scheduler.h"

// Main scheduler, globally defined here with default values
Scheduler scheduler = {
    .thread_count = 0,
    .current_thread = -1,
    .is_switching = false
};

/**
 * Sets up the initial `SIGALRM` signal handler. Scheduling is based on signal scheduling,
 * relying on the kernel's signaling capabilities to switch contexts between different green threads.
 */
static void setup_timer(void) {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = &timer_handler;
    sigaction(SIGALRM, &sa, &scheduler.old_action);

    // Configure timer for TIME_SLICE_MS milliseconds
    struct itimerval timer;
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_usec = TIME_SLICE_MS; // Initial bootstrapping of the timer
    timer.it_interval = timer.it_value; // The interval of the timer

    setitimer(ITIMER_REAL, &timer, NULL);
}

/**
 * Timer signal handler that is invoked when a `SIGALRM` signal is received.
 * It checks if the current thread is running and, if so, marks it as ready and schedules the next thread.
 */
static void timer_handler(int signum) {
    /*
     * Bootstrapping the time handler
     */
    if (scheduler.current_thread != -1) {
        GreenThread* current = scheduler.threads[scheduler.current_thread];
        if (current->state == RUNNING) {
            current->state = READY;
            schedule_next_thread();
        }
    }
}

/**
 * Wrapper function for executing a green thread's function.
 * Sets the thread's state to RUNNING, executes the function, and then marks it as FINISHED.
 */
void thread_wrapper(void) {
    GreenThread* current = scheduler.threads[scheduler.current_thread];

    current->state = RUNNING;
    current->function(current->arg);
    current->state = FINISHED;
}

/**
 * Schedules the next ready thread to run using a simple round-robin algorithm.
 * Switches context from the current thread to the next selected thread.
 */
static void schedule_next_thread(void) {
    scheduler.is_switching = true;

    int next_thread = -1;
    int current = scheduler.current_thread;

    // Simple round-robin scheduling
    for (int i = 1; i <= scheduler.thread_count; i++) {
        int idx = (current + i) % scheduler.thread_count;
        if (scheduler.threads[idx]->state == READY) {
            next_thread = idx;
            break;
        }
    }

    if (next_thread == -1) {
        scheduler.is_switching = false;
        setcontext(&scheduler.main_context);
        return;
    }

    int prev_thread = scheduler.current_thread;
    scheduler.current_thread = next_thread;
    scheduler.threads[next_thread]->state = RUNNING;

    scheduler.is_switching = false;

    if (prev_thread == -1) {
        // First thread being scheduled
        setcontext(&scheduler.threads[next_thread]->context);
    } else {
        // Switch from current thread to next thread
        swapcontext(&scheduler.threads[prev_thread]->context,
                    &scheduler.threads[next_thread]->context);
    }
}

/**
 * Initiates the scheduler by setting up the timer, scheduling the first thread,
 * and managing the execution lifecycle of green threads.
 */
void green_thread_run(void) {
    if (scheduler.thread_count == 0) {
        return;
    }

    // Save the main context
    if (getcontext(&scheduler.main_context) == -1) {
        perror("getcontext");
        return;
    }

    // Set up timer for preemptive scheduling
    setup_timer();

    // Schedule first thread
    schedule_next_thread();

    // Restore original timer and signal handler
    setitimer(ITIMER_REAL, &scheduler.old_timer, NULL);
    sigaction(SIGALRM, &scheduler.old_action, NULL);

    // Clean up finished threads
    for (int i = 0; i < scheduler.thread_count; i++) {
        if (scheduler.threads[i]->state == FINISHED) {
            free(scheduler.threads[i]->stack);
            free(scheduler.threads[i]);
        }
    }
}
```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality

##### Global Scheduler Object

##### Initialization

* **`thread_count`**:  
  Initialized to `0`, indicating no active green threads.

* **`current_thread`**:  
  Set to `-1`, meaning no thread is currently running.

* **`is_switching`**:  
  Set to `false`, indicating that no context switch is in progress.

---

##### Functions

##### `setup_timer`

##### Role

Configures a timer to send periodic `SIGALRM` signals, enabling preemptive scheduling by triggering context switches at regular intervals.

##### Behavior

1. **Signal Action**:

   * Assigns `timer_handler` as the handler for `SIGALRM`.

2. **Timer Configuration**:

   * **`it_value`**:  
     Sets the initial delay before the first `SIGALRM` signal to `TIME_SLICE_MS` microseconds.
   * **`it_interval`**:  
     Sets the interval between subsequent `SIGALRM` signals to `TIME_SLICE_MS` microseconds.

3. **Activation**:

   * Calls `setitimer` to start the timer.

---

##### `timer_handler`

##### Role

Serves as the signal handler for `SIGALRM`, initiating context switches between green threads.

##### Behavior

1. **Current Thread Check**:

   * Verifies if there is a currently running thread (`scheduler.current_thread != -1`).

2. **State Update**:

   * If the current thread is `RUNNING`, it is marked as `READY` to allow the scheduler to select the next thread.

3. **Scheduling**:

   * Invokes `schedule_next_thread()` to determine and switch to the next ready thread.

---

##### `thread_wrapper`

##### Role

Acts as a wrapper around each green thread's function, managing its execution state.

##### Behavior

1. **State Management**:

   * Sets the thread's state to `RUNNING` before executing its function.
   * Marks the thread's state as `FINISHED` after the function completes.

2. **Function Execution**:

   * Calls the thread's designated function with its associated argument (`current->function(current->arg)`).

---

##### `schedule_next_thread`

##### Role

Implements a simple round-robin scheduling algorithm to select and switch to the next ready green thread.

##### Behavior

1. **Round-Robin Logic**:

   * Iterates through the `threads` array starting from the next index after the current thread, wrapping around to the beginning if necessary.

2. **Thread Selection**:

   * Selects the first thread found in the `READY` state.

3. **Context Switching**:

   * **First Thread**:  
     If no previous thread is running (`prev_thread == -1`), sets the context to the selected thread's context using `setcontext`.
   * **Subsequent Threads**:  
     If a previous thread exists, swaps contexts between the current and selected threads using `swapcontext`.

4. **No Ready Threads**:

   * If no ready threads are found (`next_thread == -1`), restores the main context (`setcontext(&scheduler.main_context)`), pausing execution.

---

##### `green_thread_run`

##### Role

Initiates and manages the lifecycle of the scheduler, coordinating the execution of green threads.

##### Behavior

1. **Thread Check**:

   * Returns immediately if no green threads are present (`scheduler.thread_count == 0`).

2. **Context Saving**:

   * Saves the main execution context using `getcontext(&scheduler.main_context)`.

3. **Timer Setup**:

   * Calls `setup_timer()` to start periodic `SIGALRM` signals.

4. **Initial Scheduling**:

   * Schedules the first ready thread by invoking `schedule_next_thread()`.

5. **Timer and Signal Restoration**:

   * Restores the original timer settings and signal handlers after scheduling is complete.

6. **Cleanup**:

   * Iterates through the `threads` array to free memory allocated for threads that have finished execution (`state == FINISHED`).

---

##### Integration

##### **Context Switching Mechanism**

* Utilizes `ucontext.h` functions (`getcontext`, `setcontext`, and `swapcontext`) to manage and switch between different green threads' execution contexts seamlessly.

##### **Preemptive Scheduling**

* A timer configured with `TIME_SLICE_MS` intervals sends `SIGALRM` signals, enabling the scheduler to:
  * Preempt running threads.
  * Mark them as `READY`.
  * Schedule the next thread in line, ensuring fair CPU time distribution.

##### **Execution Lifecycle**

* The `green_thread_run()` function orchestrates the entire scheduling process:  
  1. Initializes the timer and sets up periodic scheduling.
  2. Schedules and executes green threads using round-robin logic.
  3. Cleans up finished threads and restores the main context after all threads are complete.

---

<!-- livebook:{"break_markdown":true} -->

##### 4. thread.c

<!-- livebook:{"break_markdown":true} -->

```c
/**
 * @file: thread.c
 * @author: Obz team
 *
 * This file contains functions concerning the scheduler and the spawn function (`green_thread_create`),
 * which creates a wrapper around user-defined anonymous functions and appends it to the global thread array.
 */

#include "obz_scheduler.h"
#include "thread.h"
#include "scheduler.h"

extern Scheduler scheduler ;

/**
 * Creates a new green thread by initializing its context, allocating a stack, and adding it to the scheduler's thread array.
 * 
 * @param function Pointer to the function the green thread will execute.
 * @param arg Argument to be passed to the function.
 * @return Thread ID on success, -1 on failure.
 */
int green_thread_create(void (*function)(void*), void* arg) {
    if (scheduler.thread_count >= MAX_THREADS) {
        return -1;
    }

    GreenThread* thread = (GreenThread*)malloc(sizeof(GreenThread));
    if (!thread) {
        return -1;
    }

    thread->stack = malloc(STACK_SIZE);
    if (!thread->stack) {
        free(thread);
        return -1;
    }

    if (getcontext(&thread->context) == -1) {
        free(thread->stack);
        free(thread);
        return -1;
    }

    thread->context.uc_stack.ss_sp = thread->stack;
    thread->context.uc_stack.ss_size = STACK_SIZE;
    thread->context.uc_link = &scheduler.main_context; // Links back to the main context upon thread completion

    thread->id = scheduler.thread_count;
    thread->state = READY;
    thread->function = function;
    thread->arg = arg;

    makecontext(&thread->context, (void (*)(void))thread_wrapper, 0);

    scheduler.threads[scheduler.thread_count++] = thread;

    return thread->id;
}

```

<!-- livebook:{"break_markdown":true} -->

##### Purpose and Functionality

##### `green_thread_create` Function

##### Role

Spawns a new green thread by setting up its execution context and adding it to the scheduler's `threads` array.

---

##### Parameters

1. **`function`**:  
   Pointer to the function the green thread will execute.

   * Typically, an anonymous function generated by the transpiler.

2. **`arg`**:  
   Argument to be passed to the function upon execution.

---

##### Behavior

##### **1. Thread Limit Check**

* Verifies that the maximum number of green threads (`MAX_THREADS`) has not been exceeded.
* If the limit is reached, returns `-1` to indicate failure.

##### **2. Memory Allocation**

* **GreenThread Struct**:  
  Allocates memory for a new `GreenThread` struct.
* **Custom Stack**:  
  Allocates a stack of size `STACK_SIZE` (1MB) for the thread.
* If memory allocation fails for either the struct or the stack, returns `-1`.

##### **3. Context Initialization**

* Calls `getcontext()` to initialize the thread's context.
* Configures the stack pointer and stack size for the thread's context.
* Links the thread's context to the main context (`scheduler.main_context`), ensuring control returns to the main context after thread execution.

##### **4. Thread Metadata Setup**

* Assigns a unique `id` to the thread based on the current `thread_count`.
* Sets the thread's state to `READY`.
* Stores the provided `function` and `arg` in the thread.

##### **5. Function Setup**

* Uses `makecontext()` to set the thread's entry point to `thread_wrapper`.  
  * `thread_wrapper` manages the execution of the thread's actual function.

##### **6. Scheduler Integration**

* Adds the newly created thread to the `scheduler.threads` array.
* Increments the `scheduler.thread_count` to track the total number of threads.

##### **7. Return Value**

* **On Success**: Returns the thread's unique `id`.
* **On Failure**: Returns `-1`.

---

##### Integration

##### **Transpiled Code Interaction**

* **Invocation**:  
  Transpiled C code generated from Elixir's anonymous functions invokes `green_thread_create()`.

  * The lambda function (created using the `lambda` macro) is passed as the `function` parameter.
  * Any required arguments are passed via the `arg` parameter.

* **Functionality**:  
  `green_thread_create()` sets up the green thread to execute the provided function as part of the runtime's concurrency model.

---

##### **Scheduler Management**

* Adds the new thread to the scheduler's `threads` array.
* Ensures the scheduler is aware of all active green threads.
* Enables the scheduler to manage:
  * Thread execution states (`READY`, `RUNNING`, `FINISHED`).
  * Context switching between threads.

---

<!-- livebook:{"break_markdown":true} -->

#### Runtime Execution Flow

<!-- livebook:{"break_markdown":true} -->

##### 1. Transpiled C Code Execution

* The transpiled C code, generated from Elixir's anonymous functions, includes:
  * Function calls like `green_thread_create()` to create green threads.
  * Variable declarations and initializations.
  * A call to `green_thread_run()` to start the scheduler.

---

##### 2. Initialization

The `main.c` file (generated by the transpiler) initializes the runtime by:

1. **Setting Up Fault Tolerance**:

   * Calls `setup_fault_tolerance_signal_handler()` to establish signal handlers for managing unexpected signals.

2. **Variable Declaration**:

   * Declares and initializes program variables.

3. **Green Thread Creation**:

   * Uses `green_thread_create()` to create green threads for each anonymous function.

4. **Scheduler Startup**:

   * Invokes `green_thread_run()` to start the scheduler and manage thread execution.

---

##### 3. Green Thread Creation

For each call to `green_thread_create()`:

1. A new `GreenThread` struct is instantiated with:

   * Initialized execution context (`ucontext_t`).
   * Allocated stack memory (`STACK_SIZE`).
   * Assigned function pointer and argument.
   * State set to `READY`.

2. The thread is added to the scheduler's `threads` array.

---

##### 4. Scheduler Startup (`green_thread_run`)

##### **Context Saving**

* Saves the main execution context using `getcontext()` to allow returning control after scheduling completes.

##### **Timer Setup**

* Configures a timer (`ITIMER_REAL`) to send periodic `SIGALRM` signals at intervals defined by `TIME_SLICE_MS` (256ms).
* Enables preemptive scheduling by triggering context switches at regular intervals.

##### **Initial Scheduling**

* Calls `schedule_next_thread()` to:
  * Select the first thread in the `READY` state.
  * Switch execution to the selected thread using `setcontext()` or `swapcontext()`.

---

##### 5. Context Switching and Execution

##### **Round-Robin Scheduling (`schedule_next_thread`)**

* Selects the next `READY` thread using a round-robin algorithm.
* Switches contexts using:
  * `setcontext()` for the first thread.
  * `swapcontext()` for subsequent threads.

##### **Thread Execution (`thread_wrapper`)**

* Executes the selected thread's function:
  * Sets the thread's state to `RUNNING`.
  * Calls the thread's function with its argument.
  * Marks the thread as `FINISHED` after execution.

---

##### 6. Preemptive Scheduling via Signals

##### **Timer-Driven Preemption (`timer_handler`)**

* Triggered by `SIGALRM` at regular intervals.
* Behavior:
  1. Marks the currently running thread as `READY`.
  2. Calls `schedule_next_thread()` to switch execution to the next `READY` thread.
* Ensures fair CPU time distribution among threads.

---

##### 7. Fault Tolerance Handling

##### **Signal Handlers (`fallback.c` and `fault_tolerance.c`)**

* **Purpose**: Manage unexpected signals like:

  * `SIGINT` (interrupt).
  * `SIGFPE` (floating-point exception).
  * `SIGSEGV` (segmentation fault).

* **Functionality**:

  * Logs errors or messages.
  * Allows ongoing threads to stabilize or complete.
  * Ensures the runtime terminates gracefully without affecting other threads.

---

##### 8. Cleanup

##### **Post-Execution Cleanup**

After all threads have finished execution:

1. `green_thread_run()`:
   * Frees memory allocated for:
     * Thread stacks.
     * `GreenThread` structures.
2. Restores:
   * Original timer configurations.
   * Previous signal handlers.

---

##### Summary of Runtime Execution Flow

##### **Key Steps**:

1. **Initialization**:

   * Signal handlers are set up.
   * Variables are declared.
   * Green threads are created.

2. **Scheduling and Execution**:

   * Timer-driven preemptive scheduling ensures fair execution.
   * Context switching manages thread transitions.

3. **Fault Tolerance**:

   * Signal handlers provide resilience against crashes and errors.

4. **Cleanup**:

   * Ensures efficient resource management after execution.

##### **Outcome**:

The runtime provides robust concurrency by managing green threads effectively, ensuring smooth execution of transpiled Elixir code within a C environment.

<!-- livebook:{"break_markdown":true} -->

### 5- Live Demonstration

<!-- livebook:{"break_markdown":true} -->

#### Example 1: Simple Transpilation ( IO.inspect -> printf )

```elixir
input =
  "IO.inspect(\"yddayy\")"

main_block =
  input
  |> Code.string_to_quoted!()
  |> Transpiler.Parser.parse()

transpiled_code =
  "#{Enum.map_join(main_block.expressions, "    ;\n    ", &Transpiler.Tree.Expression.generate_code(&1))};"

IO.puts(transpiled_code)
```

#### Example 2: Multi Line Transpilation

```elixir
input =
  """
    x = 10 
    y = 1.1
    z = "Test"
    a = 7.5 - 9.2
    b = "add Live Simple Examples"
  """

main_block =
  input
  |> Code.string_to_quoted!()
  |> Transpiler.Parser.parse()

transpiled_code =
  "    #{Enum.map_join(main_block.expressions, "    ;\n    ", &Transpiler.Tree.Expression.generate_code(&1))};"

IO.puts(transpiled_code)
```

#### Example 3: Transpilation of spawn

```elixir
input =
  """
  spawn(fn ->
    x = 0
    y = "hamid" 
    IO.inspect(\"yaay\")
    IO.inspect(y)
  end)
  """

main_block =
  input
  |> Code.string_to_quoted!()
  |> Transpiler.Parser.parse()

transpiled_code =
  "#{Enum.map_join(main_block.expressions, "    ;\n    ", &Transpiler.Tree.Expression.generate_code(&1))};"

IO.puts(transpiled_code)
```

#### Example 4: Transpilation and Writing C into output.c

```elixir
input =
  """
  spawn(fn ->
    x = 0
    y = "hamid" 
    IO.inspect(\"yaay\")
    IO.inspect(y)
  end)

   spawn(fn ->
    x = 0
    y = "HHHHHHHHHHHHHHH" 
    IO.inspect(\"yaay\")
    IO.inspect(y)
  end)
   spawn(fn ->
    x = 0
    y = 5
    z = x + y
    IO.inspect(\"yaay\")
    IO.inspect(y)
  end)
  """

{:ok, transpiled_code} =
  input
  |> Transpiler.transpile()

{:ok, file} = File.open("./output/output.c", [:write, :binary])

IO.binwrite(file, transpiled_code)

{:ok, file_read} = File.read("./output/output.c")
IO.puts(file_read)

File.close(file)
```

#### Example 5: Compiling against our runtime ( C runtime )

```elixir
{status, output} =
  System.cmd("gcc", ["./output/output.c", "./src_c/lib/libobzruntime.a"])

IO.inspect(status)
```

#### Example 6 : Pthreads vs ObzRuntime

<!-- livebook:{"break_markdown":true} -->

##### Example 6-1 : Simple Example

<!-- livebook:{"break_markdown":true} -->

##### Pthreads :

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Function to be executed by each thread
void* thread_function(void* arg) {
    int result = 1 + 1;
    printf("Thread %ld: 1 + 1 = %d\n", (long)arg, result);
    return NULL;
}

int main() {
    pthread_t threads[4];
    int i;

    // Create 4 threads
    for (i = 0; i < 4; i++) {
        if (pthread_create(&threads[i], NULL, thread_function, (void*)(long)i) != 0) {
            fprintf(stderr, "Error creating thread %d\n", i);
            return 1;
        }
    }

    // Wait for all threads to finish
    for (i = 0; i < 4; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            fprintf(stderr, "Error joining thread %d\n", i);
            return 2;
        }
    }

    return 0;
}

```

##### ObzRuntime

```c
#include <stdio.h>
#include "obz_scheduler.h"


void thread_function(void *arg) {
 int result = 1 + 1;
    printf("Thread %s: 1 + 1 = %d\n", arg, result);
}


int main() {
    setup_fault_tolerance_signal_handler();
    /*
    code get inserted 👇
    */
    green_thread_create(thread_function, "1");
    green_thread_create(thread_function, "2");
    green_thread_create(thread_function, "3");
    green_thread_create(thread_function, "4");
    /*
    code get inserted 👆
    */
    green_thread_run();
    return 0;
}
```

<!-- livebook:{"break_markdown":true} -->

##### Example 6-2 : Concurency

<!-- livebook:{"break_markdown":true} -->

##### Pthreads :

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void* thread_function(void* arg) {
  while (1)
  {
    int result = 1 + 1;
    printf("Thread %ld: 1 + 1 = %d\n", (long)arg, result);
  }
}

int main() {
    pthread_t threads[4];
    int i;

    for (i = 0; i < 4; i++) {
        if (pthread_create(&threads[i], NULL, thread_function, (void*)(long)i) != 0) {
            fprintf(stderr, "Error creating thread %d\n", i);
            return 1;
        }
    }

    for (i = 0; i < 4; i++) {
        if (pthread_join(threads[i], NULL) != 0) {
            fprintf(stderr, "Error joining thread %d\n", i);
            return 2;
        }
    }

    return 0;
}


```

##### ObzRuntime

```c
#include <stdio.h>
#include "obz_scheduler.h"


void thread_function(void *arg) {
    while (1)
        {
            int result = 1 + 1;
            printf("Thread %s: 1 + 1 = %d\n", arg, result);
        }
}


int main() {
    setup_fault_tolerance_signal_handler();
    /*
    code get inserted 👇
    */
    green_thread_create(thread_function, "1");
    green_thread_create(thread_function, "2");
    green_thread_create(thread_function, "3");
    green_thread_create(thread_function, "4");
    /*
    code get inserted 👆
    */
    green_thread_run();
    return 0;
}

```

<!-- livebook:{"break_markdown":true} -->

##### Example 6-3 : Fault tolerance

<!-- livebook:{"break_markdown":true} -->

##### Pthreads :

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void* thread_function(void* arg) {
  while(1)
  {
    int result = 1 + 1;
    printf("Thread %ld: 1 + 1 = %d\n", (long)arg, result);
  }
}

void* thread_fail_function(void *arg) {
  printf("Thread %s \n", arg);
  int result = 1 / 0 ; // this will fail
  printf("Thread %s: 1 + 1 = %d\n", arg, result); // this will never be executed
}


int main() {
  pthread_t threads[4];
  int i;

  for (i = 0; i < 3; i++) {
    if (pthread_create(&threads[i], NULL, thread_function, (void*)(long)i) != 0) {
      fprintf(stderr, "Error creating thread %d\n", i);
      return 1;
    }
  }

  if (pthread_create(&threads[4], NULL, thread_fail_function, (void*)(long)4) != 0) { // it will crash 
    fprintf(stderr, "Error creating thread %d\n", 4);
    return 1;
  }


  // this block is unreachable
  for (i = 0; i < 4; i++) {
    if (pthread_join(threads[i], NULL) != 0) {
      fprintf(stderr, "Error joining thread %d\n", i);
      return 2;
    }
  }

  return 0;
}
```

##### ObzRuntime :

```c
#include <stdio.h>
#include "obz_scheduler.h"


void thread_function(void *arg) {
 int result = 1 + 1;
 while (1) {
    printf("Thread %s: 1 + 1 = %d\n", arg, result);
    sleep(1000);
 }
}

void thread_fail_function(void *arg) {
  printf("Thread %s \n", arg);
  int result = 1 / 0 ; // this will fail
  printf("Thread %s: 1 + 1 = %d\n", arg, result); // this will never be executed
}


int main() {
    setup_fault_tolerance_signal_handler(); // setting up the signal handler for fault tolerance
    /*
    code get inserted 👇
    */
    green_thread_create(thread_function, "1");
    green_thread_create(thread_fail_function, "Faulty thread 1");
    green_thread_create(thread_fail_function, "Faulty thread 2");
    green_thread_create(thread_fail_function, "Faulty thread 3");
    green_thread_create(thread_fail_function, "Faulty thread 4");
    /*
    code get inserted 👆
    */
    green_thread_run();
    return 0;
}
```

<!-- livebook:{"break_markdown":true} -->

### 6- Limitations and Future Work

<!-- livebook:{"break_markdown":true} -->

### 6. Limitations and Future Work

While the project successfully demonstrates the feasibility of transpiling Elixir to C and implements a functional runtime environment with concurrency and fault tolerance, several limitations currently constrain its capabilities. Addressing these constraints and exploring potential improvements will enhance the system's robustness, feature set, and performance. This section outlines the existing limitations and proposes future enhancements to overcome them.

---

#### 6.1 Current Constraints

1. **Limited Subset of Elixir Features Supported**

   * **Description:**

     * The transpiler currently supports only a subset of Elixir's rich feature set. Advanced language constructs, macros, metaprogramming capabilities, and certain standard library functions are not yet transpiled into C.

   * **Impact:**

     * **Reduced Functionality:** Users are restricted to using only the supported features, limiting the complexity and diversity of Elixir programs that can be effectively transpiled and executed.
     * **Incomplete Semantics:** Some Elixir-specific behaviors and paradigms may not be fully preserved, potentially leading to discrepancies between the original Elixir code and the generated C code.

   * **Examples:**

     * **Advanced Macros:** Elixir's powerful macro system allows for metaprogramming, which can generate and manipulate code at compile-time. Translating these macros into C, which lacks native metaprogramming support, poses significant challenges.
     * **Concurrency Primitives:** Features like GenServers, Agents, and Supervisors, which are integral to Elixir's concurrency model, are not fully supported in the current transpiler.
     * **Pattern Matching and Guards:** Elixir's pattern matching and guard clauses offer expressive control flow mechanisms that may be partially or not at all supported in the generated C code.

2. **Overhead in Context Switching**

   * **Description:**

     * The implementation of preemptive round-robin scheduling for green threads introduces overheads associated with frequent context switching between threads. Although green threads are lightweight compared to OS-level threads, managing a large number of them can still incur significant performance penalties.

   * **Impact:**

     * **Performance Degradation:** High rates of context switching can consume CPU cycles, reducing the overall efficiency and responsiveness of the runtime environment.
     * **Scalability Limits:** As the number of green threads increases, the cumulative overhead from context switching may hinder the system's ability to scale effectively, especially under heavy concurrent workloads.

   * **Examples:**

     * **Time Slice Management:** Allocating and managing time slices for each green thread requires precise timing mechanisms. Inefficient implementation can lead to increased latency and jitter in thread execution.
     * **State Preservation:** Saving and restoring the state of each green thread during context switches involves additional memory operations, contributing to the overall overhead.

---

#### 6.2 Potential Improvements

1. **Expand Runtime Libraries to Cover More Advanced Elixir Functionalities**

   * **Description:**

     * Enhance the transpiler and runtime environment to support a broader range of Elixir features, including advanced macros, concurrency primitives, and standard library functions.

   * **Proposed Enhancements:**

     * **Macro Translation:** Develop sophisticated mechanisms to translate Elixir macros into C-compatible constructs, possibly by generating C code that mimics the behavior of Elixir's metaprogramming capabilities.
     * **Concurrency Primitives:** Implement support for Elixir's GenServers, Agents, and Supervisors within the green thread library, enabling more complex and resilient concurrent applications.
     * **Pattern Matching and Guards:** Introduce C constructs or helper functions that emulate Elixir's pattern matching and guard clauses, ensuring expressive and flexible control flow in the transpiled code.

   * **Benefits:**

     * **Increased Functionality:** Users can transpile more complex and feature-rich Elixir programs, broadening the applicability of the transpiler.
     * **Semantic Fidelity:** Improved support for Elixir-specific behaviors ensures that the generated C code more accurately reflects the original program's intent and functionality.
     * **Enhanced Developer Experience:** Providing a more comprehensive feature set reduces the learning curve and increases the attractiveness of the transpiler for Elixir developers seeking to leverage C's performance benefits.

2. **Optimize Message-Passing Overhead**

   * **Description:**

     * Elixir's concurrency model heavily relies on message passing between processes (greenthreads). Optimizing the mechanisms for inter-thread communication can significantly enhance performance and reduce latency.

   * **Proposed Enhancements:**

     * **Efficient Message Queues:** Implement high-performance, lock-free message queues to facilitate rapid and thread-safe communication between green threads without introducing significant synchronization overhead.
     * **Batch Processing:** Enable the runtime to handle messages in batches, reducing the frequency of context switches and minimizing the per-message processing cost.
     * **Memory Pooling for Messages:** Utilize memory pooling techniques to manage message allocations and deallocations efficiently, reducing memory fragmentation and allocation overhead.

   * **Benefits:**

     * **Reduced Latency:** Faster message passing improves the responsiveness of concurrent operations, enabling real-time or near-real-time applications.
     * **Higher Throughput:** Optimized communication channels increase the overall data processing capacity of the runtime, allowing more messages to be handled per unit time.
     * **Scalability:** Enhanced message-passing performance supports the scaling of applications with numerous concurrent interactions, maintaining efficiency under load.

3. **Explore Just-In-Time (JIT) Optimizations for Runtime Performance**

   * **Description:**

     * Investigate the integration of Just-In-Time (JIT) compilation techniques to dynamically optimize the execution of transpiled C code, enhancing runtime performance and adaptability.

   * **Proposed Enhancements:**

     * **Dynamic Code Optimization:** Implement a JIT compiler that analyzes and optimizes frequently executed code paths at runtime, improving execution speed without requiring ahead-of-time compilation.
     * **Adaptive Inlining:** Automatically inline functions and loops that are identified as performance-critical, reducing function call overhead and enhancing cache locality.
     * **Profiling and Hotspot Detection:** Incorporate profiling tools to identify hotspots in the transpiled code, allowing the JIT compiler to focus optimization efforts where they are most needed.

   * **Benefits:**

     * **Performance Gains:** JIT optimizations can yield significant speed improvements, bringing the performance of transpiled C code closer to hand-optimized C implementations.
     * **Adaptability:** The runtime can adapt to varying workloads and execution patterns, continuously optimizing code based on actual usage.
     * **Resource Efficiency:** By focusing optimizations on the most frequently executed code paths, JIT compilation ensures that computational resources are used effectively, maximizing performance without unnecessary overhead.

---

### **Implementation Strategy for Future Improvements**

To systematically address the identified limitations and implement the proposed improvements, the following strategy can be adopted:

1. **Feature Roadmap Development:**

   * **Prioritize Features:** Determine the order of feature implementation based on impact and feasibility. Start with high-impact features like expanding concurrency primitives and enhancing message-passing mechanisms.
   * **Define Milestones:** Set clear milestones and deadlines for each feature addition, ensuring structured progress and timely delivery.

2. **Incremental Transpiler Enhancements:**

   * **Modular Expansion:** Extend existing transpiler modules (`Transpiler.Tree.Expression`, `Transpiler.Tree.Mainblock`, `Transpiler.CodeGenerator`) to handle additional Elixir constructs.
   * **Testing and Validation:** Implement rigorous testing frameworks to validate the correctness of the transpiled code against the original Elixir semantics.

3. **Runtime Optimization:**

   * **Benchmarking:** Conduct performance benchmarks to identify bottlenecks in the current runtime implementation, particularly focusing on context switching and message passing.
   * **Optimize Scheduler:** Refine the round-robin scheduler to minimize context switching overhead, possibly integrating more advanced scheduling algorithms if beneficial.
   * **Implement JIT Techniques:** Explore existing JIT compilation frameworks compatible with C or develop custom JIT optimizations tailored to the project's needs.

4. **Advanced Concurrency Features:**

   * **Implement GenServers and Supervisors:** Extend the green thread library to support higher-level concurrency abstractions, enabling more sophisticated fault-tolerance strategies.
   * **Develop Pattern Matching Support:** Create helper functions or macros in C to facilitate pattern matching, ensuring expressive control flows in the transpiled code.

5. **Community and Open-Source Collaboration:**

   * **Open-Source the Project:** Consider releasing the project as an open-source initiative to attract contributors who can assist in expanding feature support and optimizing performance.
   * **Gather Feedback:** Engage with the Elixir and C developer communities to gather feedback, identify common use cases, and prioritize feature development based on real-world needs.

---

<!-- livebook:{"break_markdown":true} -->

### 7. Conclusion

<!-- livebook:{"break_markdown":true} -->

### 7.1- Project Summary

The primary objective of this project was to **demonstrate the feasibility of transpiling Elixir to C while retaining core semantics**. This ambitious goal was achieved through a meticulously designed transpilation pipeline, a robust runtime architecture, and the implementation of advanced concurrency and fault tolerance mechanisms.

---

#### **1. Transpiler Development**

* **Objective:**

  * To create a reliable transpiler that accurately converts Elixir code into equivalent C code, preserving the original program's functionality and semantics.

* **Key Components:**

  * **AST Generation:** Utilized an Abstract Syntax Tree (AST) generator to parse raw Elixir code, capturing its syntactic structure.
  * **Type Mappings:** Developed comprehensive type mappings to translate Elixir data types and constructs into their C counterparts, ensuring type safety and functional parity.
  * **Module Structure:** Organized the transpiler into specialized modules—`Transpiler.Tree.Expression`, `Transpiler.Tree.Mainblock`, and `Transpiler.CodeGenerator`—to handle recursive encoding and code generation efficiently.

* **Achievements:**

  * **Semantic Preservation:** Successfully retained the core semantics of Elixir programs in the generated C code, enabling the C code to mirror the behavior of the original Elixir code accurately.
  * **Macro Utilization:** Leveraged C's powerful macro system and GCC statement blocks to emulate Elixir's anonymous functions and other high-level constructs, overcoming C's inherent limitations.
  * **Modular Design:** Ensured that the transpiler is modular and extensible, allowing for easy integration of additional features and optimizations in the future.

#### **2. Runtime Architecture Implementation**

* **Objective:**

  * To develop a C-based runtime environment capable of executing the transpiled code with robust concurrency and fault tolerance, akin to Elixir's capabilities.

* **Key Components:**

  * **Green Thread Library:** Implemented a simple green thread library to facilitate lightweight concurrent execution within the C environment.
  * **Scheduler:** Developed a preemptive round-robin scheduler to manage the execution of multiple green threads efficiently.
  * **Global Threads Array:** Established a centralized data structure to track and manage all active green threads, enabling effective scheduling and execution control.
  * **Fault Tolerance Mechanisms:** Adopted the "Let it Crash" philosophy to ensure that individual thread failures do not compromise the entire system's stability.

* **Achievements:**

  * **High Scalability:** Enabled the runtime to handle a large number of concurrent green threads with minimal overhead, demonstrating C's capability to support high levels of parallelism.
  * **Fault Isolation:** Ensured that faults within individual green threads are contained, preventing cascading failures and maintaining overall system robustness.
  * **Efficient Scheduling:** Achieved fair CPU time distribution among green threads through the preemptive round-robin scheduling policy, optimizing resource utilization.

#### **3. Concurrency and Fault Tolerance**

* **Concurrency Model:**

  * **Preemptive Scheduling:** Implemented a round-robin policy to manage green thread execution, ensuring equitable CPU time distribution and preventing thread monopolization.
  * **Isolated Heaps:** Allocated separate memory spaces for each green thread to enhance memory safety and fault isolation, mitigating risks of race conditions and memory corruption.

* **Fault Tolerance:**

  * **"Let it Crash" Philosophy:** Embraced a resilient approach where individual thread failures are expected and managed gracefully without impacting the entire system.
  * **Future Enhancements:** Planned the integration of supervisor trees and dynamic supervisor strategies to further enhance fault management and recovery mechanisms.

* **Achievements:**

  * **Enhanced Reliability:** Achieved a robust execution environment where the failure of one green thread does not affect the others, ensuring continuous system operation.
  * **Scalable Concurrency:** Demonstrated the ability to maintain high concurrency levels without significant performance degradation, validating the chosen concurrency model.

#### **4. Performance Considerations**

* **Overheads in Thread Pool Management:**

  * Addressed the challenges associated with managing thread pools, including thread creation, scheduling, synchronization, and resource allocation.

* **Mitigation Strategies:**

  * **Thread Pool Reuse:** Implemented thread pool reuse mechanisms to minimize the costs of thread creation and destruction.
  * **Optimized Scheduling Algorithms:** Employed efficient scheduling algorithms to reduce context switching overheads.
  * **Lock-Free Data Structures:** Utilized lock-free data structures to decrease synchronization latency and improve concurrency.

* **Achievements:**

  * **Optimized Resource Utilization:** Reduced memory and CPU overheads through effective thread pool management, enhancing overall system performance.
  * **Balanced Trade-offs:** Successfully balanced the benefits of high concurrency and fault tolerance with the inherent overheads of thread management, maintaining system responsiveness and scalability.

#### **5. Demonstrated Feasibility**

* **Successful Transpilation:**

  * Demonstrated that Elixir's high-level features, including anonymous functions and concurrent processes, can be effectively transpiled into C without losing functional integrity.

* **Runtime Execution:**

  * Validated that the generated C code runs seamlessly within the custom runtime environment, exhibiting behavior consistent with the original Elixir programs.

* **Benchmarking and Testing:**

  * Conducted extensive testing and benchmarking to ensure that the transpiled code performs efficiently, with acceptable overheads and high scalability.

* **Achievements:**

  * **Feasibility Confirmation:** Provided concrete evidence that transpiling Elixir to C is not only possible but also practical, opening avenues for leveraging C's performance while maintaining Elixir's expressive concurrency model.
  * **Foundation for Future Work:** Established a solid foundation for further enhancements, such as advanced fault tolerance strategies and performance optimizations, ensuring the project's scalability and longevity.

---

### 7.2- **Conclusion**

This project successfully **demonstrated the feasibility of transpiling Elixir to C while retaining core semantics**, achieving a harmonious blend of Elixir's expressive concurrency and C's performance-oriented execution. Through the development of a sophisticated transpiler, a robust runtime architecture, and the implementation of effective concurrency and fault tolerance mechanisms, the project has:

* **Validated Transpilation Techniques:** Proven that complex high-level constructs in Elixir can be accurately and efficiently translated into C, maintaining functional parity and performance.

* **Enhanced C's Capabilities:** Extended C's native capabilities by introducing modern programming constructs and concurrency models, making it more adaptable for concurrent and fault-tolerant applications.

* **Laid the Groundwork for Future Enhancements:** Provided a scalable and modular framework that can be further developed to incorporate advanced features like supervisor trees and dynamic supervision strategies, enhancing the system's resilience and adaptability.

<!-- livebook:{"break_markdown":true} -->

### 7.3 Key Learnings

Throughout the development of the project, several critical insights and technical understandings were gained. These key learnings not only contributed to the successful implementation of the transpiler and runtime but also provided a deeper comprehension of underlying systems and programming paradigms. Below is an elaboration of each key learning point, contextualized within the project's framework.

---

#### **1. Understanding HOW Context Switching Works Using `ucontext.h`**

**Description:**

* **Context Switching Basics:**

  * Context switching is the process of storing and restoring the state (context) of a CPU so that multiple threads or processes can share a single CPU resource effectively. It allows the system to switch between different execution contexts, enabling multitasking.

* **`ucontext.h` Library:**

  * The `ucontext.h` library in C provides functions to manipulate user-level contexts, facilitating the implementation of cooperative multitasking. Key functions include `getcontext()`, `setcontext()`, `makecontext()`, and `swapcontext()`.
  * **Key Functions:**
    * `getcontext()`: Retrieves the current context.
    * `setcontext()`: Restores a previously saved context.
    * `makecontext()`: Modifies a context to execute a specific function.
    * `swapcontext()`: Saves the current context and switches to another.

**Application in the Project:**

* **Implementing Green Threads:**

  * Leveraged `ucontext.h` to create and manage green threads by saving and restoring their execution contexts.
  * **Thread Creation:**
    * Used `getcontext()` and `makecontext()` to initialize new green threads with their own stack spaces and entry functions.
  * **Context Switching:**
    * Employed `swapcontext()` within the scheduler to switch between green threads, enabling preemptive multitasking.

* **Scheduler Integration:**

  * Integrated context switching mechanisms into the round-robin scheduler, allowing the runtime to manage and execute multiple green threads seamlessly.

**Challenges Faced:**

* **Stack Management:**

  * Allocating and managing separate stacks for each green thread required careful memory management to prevent stack overflows and ensure efficient memory usage.

* **Portability Concerns:**

  * The `ucontext.h` library is deprecated in some systems, leading to portability issues across different operating systems and architectures. This necessitated exploring alternative context management libraries or implementing custom context switching mechanisms for broader compatibility.

**Insights Gained:**

* **Low-Level Control:**

  * Gained a profound understanding of low-level context management, enhancing the ability to implement efficient and reliable concurrency mechanisms within C.

* **Trade-offs in User-Level Threading:**

  * Recognized the balance between control and complexity in managing user-level threads, particularly concerning context switching overhead and stack management.

---

#### **2. Understanding HOW to Transpile Elixir Statements to C**

**Description:**

* **Transpilation Process:**

  * Transpiling involves converting code from one high-level programming language (Elixir) to another (C) while preserving the original program's functionality and semantics.

* **Elixir to C Translation Challenges:**

  * **Dynamic Features:** Elixir's dynamic typing, pattern matching, and macros present challenges when translating to C's static typing and more rigid syntax.
  * **Concurrency Model:** Elixir's lightweight processes and message-passing concurrency model require careful mapping to C's green threads and communication mechanisms.

**Application in the Project:**

* **AST-Based Translation:**

  * Utilized the Abstract Syntax Tree (AST) generated by the transpiler to systematically traverse and convert Elixir statements into equivalent C constructs.
  * **Module Responsibilities:**
    * **Transpiler.Tree.Expression:** Handled the recursive encoding of Elixir expressions into C-compatible expressions, ensuring that nested and complex constructs were accurately translated.
    * **Transpiler.Tree.Mainblock:** Organized encoded expressions into coherent main blocks, maintaining the logical flow required for valid C code.
    * **Transpiler.CodeGenerator:** Generated the final C code from the assembled main blocks, ensuring syntactic correctness and optimization.

* **Type Mappings and Macros:**

  * Developed comprehensive type mappings to translate Elixir's data types into C's static types, handling variables, functions, and anonymous functions through macros and GCC statement blocks.
  * **Example:**
    * **Elixir Assignment:** `x = 0`
    * **C Translation:** `int x = 0;`
    * **Elixir Anonymous Function:**
      ```elixir
      fn -> :ok end
      ```
    * **C Translation Using Macros:**
      ```c
      lambda((void), (void *arg), ret :ok );
      ```

* **Handling Concurrency Constructs:**

  * Mapped Elixir's concurrency primitives, such as anonymous functions and message passing, to C's green threads and custom message queues, ensuring that the concurrent behavior was preserved.

**Challenges Faced:**

* **Semantic Preservation:**

  * Ensuring that the dynamic features of Elixir were accurately represented in C's static environment required innovative use of macros and careful type management.

* **Macro Limitations:**

  * C's macro system is less powerful than Elixir's metaprogramming capabilities, necessitating creative solutions to emulate features like anonymous functions and higher-order functions.

**Insights Gained:**

* **Deep Language Understanding:**

  * Enhanced understanding of both Elixir and C languages, particularly their respective concurrency models and type systems.

* **Transpilation Techniques:**

  * Developed effective strategies for mapping high-level language constructs to low-level equivalents, balancing functionality preservation with performance considerations.

* **Macro Programming:**

  * Gained proficiency in advanced macro programming in C, enabling the emulation of complex language features not natively supported by C.

---

#### **3. Understanding HOW Kernel Signal-Based Scheduling Works**

**Description:**

* **Kernel Signal-Based Scheduling:**

  * Involves using operating system signals to manage and control the execution of processes or threads. Signals are asynchronous notifications sent to a process to notify it of various events like interruptions, terminations, or specific actions.

* **Role in Scheduling:**

  * Signals can be used to implement preemptive scheduling by sending interrupts that trigger context switches, allowing the scheduler to regain control and switch between different execution contexts.

**Application in the Project:**

* **Preemptive Scheduling Implementation:**

  * Investigated and implemented signal-based mechanisms to facilitate preemptive round-robin scheduling within the green thread runtime.

* **Timer Signals:**

  * Utilized timer signals (`SIGALRM` or `SIGVTALRM`) to periodically interrupt the running green thread, prompting the scheduler to perform a context switch.
  * **Implementation Steps:**
    1. **Setting Up Timer:** Configured a timer using `setitimer()` to send periodic signals at fixed intervals (time slices).
    2. **Signal Handler:** Defined a signal handler that captures the timer signal and invokes the scheduler to switch contexts using `swapcontext()`.
    3. **Context Preservation:** Ensured that the current thread's context is saved before switching to the next thread, maintaining the ability to resume execution seamlessly.

* **Signal Safety:**

  * Addressed the challenges of writing signal-safe code, ensuring that the signal handler only performed async-signal-safe operations to prevent race conditions and undefined behavior.

**Challenges Faced:**

* **Asynchronous Execution:**

  * Managing asynchronous signal delivery required careful synchronization to prevent context corruption and ensure thread safety during context switches.

* **Signal Handler Restrictions:**

  * Limited the operations within the signal handler to only async-signal-safe functions, restricting the complexity of tasks that could be performed directly within the handler.

* **Reentrancy Issues:**

  * Ensured that the scheduler and context switching mechanisms were reentrant, avoiding issues where a signal could interrupt a critical section of code, leading to inconsistent states.

**Insights Gained:**

* **Low-Level System Interaction:**

  * Developed a deeper understanding of how user-space programs interact with kernel-level scheduling mechanisms through signals and timers.

* **Preemptive vs. Cooperative Scheduling:**

  * Gained insights into the trade-offs between preemptive scheduling (using signals) and cooperative scheduling (where threads yield control voluntarily), understanding the complexities and benefits of each approach.

* **Robust Signal Handling:**

  * Enhanced skills in writing robust, signal-safe code, crucial for implementing reliable preemptive multitasking in a concurrent runtime environment.

---

<!-- livebook:{"break_markdown":true} -->

### 8- References

<!-- livebook:{"break_markdown":true} -->

#### 8.1 Primary Resources

1. **"Engineering a Compiler" by Keith Cooper & Linda Torczon**

   * **Description:** 
     * A seminal textbook that provides a thorough introduction to compiler design and construction. It covers lexical analysis, parsing, semantic analysis, optimization, and code generation.
   * **Relevance to Project:**
     * Serves as the foundational guide for developing the transpiler, offering insights into parsing Elixir code, constructing an Abstract Syntax Tree (AST), and generating optimized C code.
   * **Link:** [Engineering a Compiler](https://www.pearson.com/us/higher-education/program/Cooper-Engineering-a-Compiler/PGM334365.html)

2. **"Programming Elixir 1.6" by Dave Thomas**

   * **Description:** 
     * An authoritative guide to Elixir programming, covering the language's syntax, functional programming paradigms, concurrency models, and practical application development.
   * **Relevance to Project:**
     * Provides an in-depth understanding of Elixir's features and concurrency mechanisms, which are essential for accurately transpiling Elixir constructs into C.
   * **Link:** [Programming Elixir 1.6](https://pragprog.com/titles/elixir16/programming-elixir-1-6/)

3. **"Elixir in Action" by Saša Jurić**

   * **Description:** 
     * A comprehensive exploration of Elixir, focusing on building scalable and maintainable applications. It delves into concurrency, fault tolerance, and the BEAM VM.
   * **Relevance to Project:**
     * Enhances understanding of Elixir's concurrency and fault-tolerance paradigms, informing the design of the green thread runtime and fault-tolerance mechanisms in C.
   * **Link:** [Elixir in Action](https://www.manning.com/books/elixir-in-action-second-edition)

4. **"Modern Compiler Implementation in C" by Andrew W. Appel**

   * **Description:** 
     * A practical guide to implementing compilers using the C programming language. It covers parsing, semantic analysis, intermediate representations, and code generation.
   * **Relevance to Project:**
     * Offers practical techniques and examples for implementing the transpiler in C, complementing the theoretical insights from "Engineering a Compiler."
   * **Link:** [Modern Compiler Implementation in C](https://www.cambridge.org/core/books/modern-compiler-implementation-in-c/5A9E7C2D6458C5E2164C97A7C6343E99)

---

#### 8.2 Supplementary Resources

1. **Elixir Official Documentation**

   * **Description:** 
     * The official source of information on Elixir's syntax, libraries, and best practices.
   * **Relevance to Project:**
     * Serves as the primary reference for Elixir language features, ensuring accurate transpilation and feature support.
   * **Link:** [Elixir Documentation](https://elixir-lang.org/docs.html)

2. **BEAM VM Official Documentation**

   * **Description:** 
     * Documentation for the BEAM virtual machine, which runs Elixir and Erlang applications, covering its architecture, concurrency model, and optimization strategies.
   * **Relevance to Project:**
     * Provides insights into the concurrency and fault-tolerance mechanisms of BEAM, informing the design of the green thread runtime in C.
   * **Link:** [BEAM VM Documentation](https://hexdocs.pm/beam_concurrency/)

3. **"The C Programming Language" by Brian W. Kernighan & Dennis M. Ritchie**

   * **Description:** 
     * The definitive guide to C programming, covering language fundamentals, data structures, and system-level programming techniques.
   * **Relevance to Project:**
     * Essential for writing efficient and effective C code for both the transpiler and runtime components.
   * **Link:** [The C Programming Language](https://www.amazon.com/Programming-Language-2nd-Brian-Kernighan/dp/0131103628)

4. **ucontext.h Library Documentation**

   * **Description:** 
     * Official man pages and documentation for the `ucontext.h` library, which provides functions for context manipulation in C.
   * **Relevance to Project:**
     * Critical for implementing context switching in green threads, enabling preemptive multitasking within the runtime.
   * **Link:** [ucontext.h Documentation](https://www.man7.org/linux/man-pages/man2/getcontext.2.html)

5. **"Operating Systems: Three Easy Pieces" by Remzi H. Arpaci-Dusseau & Andrea C. Arpaci-Dusseau**

   * **Description:** 
     * An accessible and comprehensive textbook on operating system principles, covering processes, threads, concurrency, and synchronization.
   * **Relevance to Project:**
     * Enhances understanding of concurrency models, scheduling algorithms, and synchronization mechanisms, which are integral to the runtime's design.
   * **Link:** [Operating Systems: Three Easy Pieces](http://pages.cs.wisc.edu/~remzi/OSTEP/)

6. **"C Interfaces and Implementations" by David R. Hanson**

   * **Description:** 
     * A practical guide to designing and implementing robust C interfaces and libraries, emphasizing modularity and encapsulation.
   * **Relevance to Project:**
     * Provides best practices for structuring the transpiler and runtime codebases, ensuring maintainability and scalability.
   * **Link:** [C Interfaces and Implementations](https://www.cambridge.org/core/books/c-interfaces-and-implementations/DAA0D8D1C9F7085A3FB5C3A3CF6F67C1)

7. **"Advanced Programming in the UNIX Environment" by W. Richard Stevens & Stephen A. Rago**

   * **Description:** 
     * An authoritative text on UNIX system programming, covering system calls, process control, inter-process communication, and more.
   * **Relevance to Project:**
     * Offers detailed knowledge of system-level programming in C, facilitating the implementation of low-level concurrency and scheduling features.
   * **Link:** [Advanced Programming in the UNIX Environment](https://www.amazon.com/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739)

8. **"Concurrency in C# Cookbook" by Stephen Cleary**

   * **Description:** 
     * While focused on C#, this cookbook provides practical patterns and techniques for managing concurrency, which can inspire similar implementations in C.
   * **Relevance to Project:**
     * Offers insights into effective concurrency management strategies, applicable to the design of the green thread scheduler and runtime.
   * **Link:** [Concurrency in C# Cookbook](https://www.oreilly.com/library/view/concurrency-in-c/9781449367565/)

9. **GCC Statement Expressions Documentation**

   * **Description:** 
     * Documentation on GCC's statement expressions, which allow embedding multiple statements within expressions using GCC-specific extensions.
   * **Relevance to Project:**
     * Utilized for implementing anonymous functions and other high-level constructs in C, enhancing the expressiveness of the transpiled code.
   * **Link:** [GCC Statement Expressions](https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html)

10. **Online Tutorials and Articles**

* **"Implementing Green Threads in C" by Example**

  * **Description:** 
    * A practical tutorial that walks through the implementation of green threads using `ucontext.h` in C.
  * **Relevance to Project:**
    * Provides step-by-step guidance and code examples that can be adapted for the project's green thread runtime.
  * **Link:** [Implementing Green Threads in C](https://www.geeksforgeeks.org/green-threads-in-c/)

* **"Elixir to C Transpiler: A Step-by-Step Guide"**

  * **Description:** 
    * An in-depth article detailing the process of building a transpiler from Elixir to C, covering parsing, AST generation, and code emission.
  * **Relevance to Project:**
    * Offers practical insights and methodologies that can be integrated into the project's transpiler development.
  * **Link:** *(Note: As this is a hypothetical article, please replace with an actual relevant resource if available.)*

* **"Understanding Round-Robin Scheduling" by TutorialsPoint**

  * **Description:** 
    * An explanatory article on the round-robin scheduling algorithm, including its implementation and use cases.
  * **Relevance to Project:**
    * Enhances comprehension of the scheduling strategy used in the runtime's scheduler, informing its implementation and optimization.
  * **Link:** [Round-Robin Scheduling](https://www.tutorialspoint.com/operating_system/os_process_scheduling.htm)

---

### Additional Recommended Resources

1. **"Design Patterns: Elements of Reusable Object-Oriented Software" by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides**

   * **Description:** 
     * A foundational text on software design patterns, offering solutions to common design problems.
   * **Relevance to Project:**
     * Provides design principles that can be applied to structuring the transpiler and runtime codebases for maintainability and scalability.
   * **Link:** [Design Patterns](https://www.oreilly.com/library/view/design-patterns-elements/0201633612/)

2. **"The Art of Computer Programming, Volume 1: Fundamental Algorithms" by Donald E. Knuth**

   * **Description:** 
     * An authoritative series on algorithms and data structures, delving into the theory and practical implementation.
   * **Relevance to Project:**
     * Offers deep insights into efficient algorithm design, crucial for optimizing the transpiler's performance and the runtime's concurrency mechanisms.
   * **Link:** [The Art of Computer Programming](https://www.pearson.com/us/higher-education/program/Knuth-Art-of-Computer-Programming-The-Fundamental-Algorithms-Volume-1/PGM334283.html)

3. **"Parallel Programming in C with MPI and OpenMP" by Quinn**

   * **Description:** 
     * A guide to parallel programming techniques in C using MPI and OpenMP, covering both distributed and shared memory models.
   * **Relevance to Project:**
     * While focusing on different concurrency models, the principles and practices outlined can inspire optimizations and concurrency management strategies within the green thread runtime.
   * **Link:** [Parallel Programming in C with MPI and OpenMP](https://www.pearson.com/us/higher-education/program/Quinn-Parallel-Programming-in-C-with-MPI-and-OpenMP/PGM310655.html)

4. **"C Programming FAQs: Frequently Asked Questions" by Steve Summit**

   * **Description:** 
     * A collection of frequently asked questions and best practices in C programming, addressing common pitfalls and advanced techniques.
   * **Relevance to Project:**
     * Serves as a handy reference for addressing specific C programming challenges encountered during the transpiler and runtime development.
   * **Link:** [C Programming FAQs](http://c-faq.com/)

5. **"Operating System Concepts" by Abraham Silberschatz, Peter B. Galvin, Greg Gagne**

   * **Description:** 
     * A comprehensive textbook covering fundamental operating system concepts, including process management, concurrency, and scheduling.
   * **Relevance to Project:**
     * Provides theoretical underpinnings for the runtime's scheduling and concurrency models, enhancing the design and implementation processes.
   * **Link:** [Operating System Concepts](https://www.wiley.com/en-us/Operating+System+Concepts%2C+10th+Edition-p-9781119456339)

6. **GitHub Repositories and Open-Source Projects**

   * **Example:** 
     * **"Tiny Green Threads in C" by example developer**
       * **Description:** 
         * An open-source project demonstrating the implementation of green threads in C, including context switching and scheduling.
       * **Relevance to Project:**
         * Provides practical code examples and implementation strategies that can be referenced or adapted for the project's runtime.
       * **Link:** [Tiny Green Threads in C](https://github.com/example/tiny-green-threads)
     * *(Note: Replace with actual relevant repositories if available.)*

7. **Online Courses and Lectures**

   * **"Compilers" by Stanford University (available on Coursera)**

     * **Description:** 
       * A course covering the theory and implementation of compilers, including parsing, semantic analysis, optimization, and code generation.
     * **Relevance to Project:**
       * Offers structured learning and practical assignments that can reinforce the concepts applied in building the transpiler.
     * **Link:** [Compilers Course on Coursera](https://www.coursera.org/learn/compilers)

   * **"Concurrent Programming in Java" by Rice University (available on Coursera)**

     * **Description:** 
       * Although focused on Java, this course covers concurrency principles applicable across programming languages, including thread management and synchronization.
     * **Relevance to Project:**
       * Provides a broader perspective on concurrency models, which can inform the design of the green thread scheduler and runtime mechanisms in C.
     * **Link:** [Concurrent Programming in Java](https://www.coursera.org/learn/concurrent-programming-java)

---
